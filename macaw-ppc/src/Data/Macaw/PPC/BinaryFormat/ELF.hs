{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeApplications #-}
module Data.Macaw.PPC.BinaryFormat.ELF (
  tocBaseForELF,
  tocEntryAddrsForElf
  ) where

import           GHC.TypeLits ( KnownNat, natVal )

import           Control.Monad ( replicateM, unless )
import qualified Data.ByteString.Char8 as C8
import qualified Data.Map.Strict as M
import           Data.Proxy ( Proxy(..) )
import qualified Data.Serialize.Get as G
import qualified Data.Set as S

import qualified Data.ElfEdit as E
import qualified Data.Macaw.AbsDomain.AbsState as MA
import qualified Data.Macaw.CFG as MC
import qualified Data.Macaw.Memory as MM
import           Data.Macaw.Types ( BVType )

-- | Given an ELF file, extract a mapping from function entry points to the
-- value of the TOC pointer (which is to be stored in r2) for that function.
--
-- The generated function is called from 'mkInitialAbsState' to set up the value
-- of r2 at the entry point to each function, which will allow macaw to discover
-- the values of loaded function pointers.
--
-- In the v1 PowerPC ABI (at least as generated by gcc), the entries are all
-- stored in the @.opd@ section.  Each entry is three pointers, where the first
-- entry is the function address and the second is the value of the TOC.  The
-- third entry is unused in C programs (it is meant for Pascal).
tocBaseForELF :: (KnownNat (MC.RegAddrWidth (MC.ArchReg ppc)), MM.MemWidth (MC.RegAddrWidth (MC.ArchReg ppc)))
              => proxy ppc
              -> E.Elf (MC.RegAddrWidth (MC.ArchReg ppc))
              -> MC.ArchSegmentOff ppc
              -> Maybe (MA.AbsValue (MC.RegAddrWidth (MC.ArchReg ppc)) (BVType (MC.RegAddrWidth (MC.ArchReg ppc))))
tocBaseForELF proxy e =
  case parseTOC proxy e of
    Left err -> error ("Error parsing .opd section: " ++ err)
    Right res -> \entryAddr -> M.lookup (MM.relativeSegmentAddr entryAddr) res

tocEntryAddrsForElf :: (MM.MemWidth (MC.RegAddrWidth (MC.ArchReg ppc)),
                         KnownNat (MC.RegAddrWidth (MC.ArchReg ppc)))
                    => proxy ppc
                    -> E.Elf (MC.RegAddrWidth (MC.ArchReg ppc))
                    -> [MM.MemAddr (MC.RegAddrWidth (MC.ArchReg ppc))]
tocEntryAddrsForElf proxy e =
  case parseTOC proxy e of
    Left err -> error ("Error parsing .opd section: " ++ err)
    Right res -> M.keys res

parseTOC :: forall ppc proxy
          . (KnownNat (MC.RegAddrWidth (MC.ArchReg ppc)), MM.MemWidth (MC.RegAddrWidth (MC.ArchReg ppc)))
         => proxy ppc
         -> E.Elf (MC.RegAddrWidth (MC.ArchReg ppc))
         -> Either String (M.Map (MM.MemAddr (MC.RegAddrWidth (MC.ArchReg ppc))) (MA.AbsValue (MC.RegAddrWidth (MC.ArchReg ppc)) (BVType (MC.RegAddrWidth (MC.ArchReg ppc)))))
parseTOC proxy e =
  case E.findSectionByName (C8.pack ".opd") e of
    [sec] ->
      G.runGet (parseFunctionDescriptors proxy (fromIntegral ptrSize)) (E.elfSectionData sec)
    _ -> error "Could not find .opd section"
  where
    ptrSize = natVal (Proxy @(MC.RegAddrWidth (MC.ArchReg ppc)))


parseFunctionDescriptors :: (MM.MemWidth (MC.RegAddrWidth (MC.ArchReg ppc)))
                         => proxy ppc
                         -> Int
                         -> G.Get (M.Map (MM.MemAddr (MC.RegAddrWidth (MC.ArchReg ppc))) (MA.AbsValue (MC.RegAddrWidth (MC.ArchReg ppc)) (BVType (MC.RegAddrWidth (MC.ArchReg ppc)))))
parseFunctionDescriptors _ ptrSize = do
  let recordBytes = (3 * ptrSize) `div` 8
  let recordParser =
        case ptrSize of
          32 -> getFunctionDescriptor G.getWord32be
          64 -> getFunctionDescriptor G.getWord64be
          _ -> error ("Invalid pointer size: " ++ show ptrSize)
  totalBytes <- G.remaining
  unless (totalBytes `mod` recordBytes == 0) $ do
    fail "The .opd section is not divisible by the record size"
  funcDescs <- replicateM (totalBytes `div` recordBytes) recordParser
  return (M.fromList funcDescs)

getFunctionDescriptor :: (Integral a, MM.MemWidth w)
                      => G.Get a
                      -> G.Get (MM.MemAddr w, MA.AbsValue w (BVType w))
getFunctionDescriptor ptrParser = do
  entryAddr <- ptrParser
  tocAddr <- ptrParser
  _ <- ptrParser
  let mso = MM.absoluteAddr (fromIntegral entryAddr)
  return (mso, MA.FinSet (S.singleton (fromIntegral tocAddr)))
