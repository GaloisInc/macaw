{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE TypeApplications #-}

module Data.Macaw.PPC.Semantics.TH
  ( genExecInstruction
  ) where

import qualified Data.ByteString as BS
import qualified Data.Constraint as C

import           Control.Lens ( (.=) )
import           Data.Proxy
import qualified Data.List as L
import qualified Data.Text as T
import           Language.Haskell.TH
import           Language.Haskell.TH.Syntax
import           GHC.TypeLits
import           Text.Read ( readMaybe )

import           Data.Parameterized.Classes
import           Data.Parameterized.FreeParamF ( FreeParamF(..) )
import qualified Data.Parameterized.Lift as LF
import qualified Data.Parameterized.Map as Map
import qualified Data.Parameterized.NatRepr as NR
import qualified Data.Parameterized.Nonce as PN
import qualified Data.Parameterized.ShapedList as SL
import           Data.Parameterized.Some ( Some(..) )
import qualified Data.Parameterized.TraversableFC as FC
import           Data.Parameterized.Witness ( Witness(..) )
import qualified Lang.Crucible.Solver.Interface as SI
import qualified Lang.Crucible.Solver.SimpleBuilder as S
import qualified Lang.Crucible.Solver.SimpleBackend as S
import qualified Lang.Crucible.Solver.Symbol as Sy
import qualified Lang.Crucible.BaseTypes as S

import qualified Dismantle.PPC as D
import qualified Dismantle.Tablegen.TH.Capture as DT

import qualified SemMC.BoundVar as BV
import           SemMC.Formula
import qualified SemMC.Architecture as A
import qualified SemMC.Architecture.Location as L
import qualified SemMC.Architecture.PPC.Eval as PE
import qualified SemMC.Architecture.PPC.Location as APPC
import qualified Data.Macaw.CFG as M
import qualified Data.Macaw.Memory as M
import qualified Data.Macaw.Types as M

import Data.Parameterized.NatRepr ( knownNat
                                  , addNat
                                  , natValue
                                  , isPosNat
                                  , testLeq
                                  )

import           Data.Macaw.PPC.Generator
import           Data.Macaw.PPC.Operand
import           Data.Macaw.PPC.PPCReg

-- run stack with --ghc-options=-ddump-splices

-- | A different parameterized pair wrapper; the one in Data.Parameterized.Map
-- hides the @tp@ parameter under an existential, while we need the variant that
-- exposes it.
data PairF a b tp = PairF (a tp) (b tp)

-- | Generate the top-level lambda with a case expression over an instruction
-- (casing on opcode)
--
-- > \ipVar (Instruction opcode operandList) ->
-- >   case opcode of
-- >     ${CASES}
--
-- where each case in ${CASES} is defined by 'mkSemanticsCase'; each case
-- matches one opcode.
instructionMatcher :: (OrdF a, LF.LiftF a,
                       A.Architecture arch,
                       L.Location arch ~ APPC.Location arch,
                       1 <= APPC.ArchRegWidth arch,
                       M.RegAddrWidth (PPCReg arch) ~ APPC.ArchRegWidth arch)
                   => Map.MapF (Witness c a) (PairF (ParameterizedFormula (Sym t) arch) (DT.CaptureInfo c a))
                   -> Q Exp
instructionMatcher formulas = do
  ipVarName <- newName "ipVal"
  opcodeVar <- newName "opcode"
  operandListVar <- newName "operands"
  let cases = map (mkSemanticsCase ipVarName operandListVar) (Map.toList formulas)
  lamE [varP ipVarName, conP 'D.Instruction [varP opcodeVar, varP operandListVar]] (caseE (varE opcodeVar) cases)

-- | Generate a single case for one opcode of the case expression.
--
-- > ADD4 -> ${BODY}
--
-- where the ${BODY} is generated by 'mkOperandListCase'
mkSemanticsCase :: (LF.LiftF a,
                    A.Architecture arch,
                    L.Location arch ~ APPC.Location arch,
                    1 <= APPC.ArchRegWidth arch,
                    M.RegAddrWidth (PPCReg arch) ~ APPC.ArchRegWidth arch)
                => Name
                -> Name
                -> Map.Pair (Witness c a) (PairF (ParameterizedFormula (Sym t) arch) (DT.CaptureInfo c a))
                -> MatchQ
mkSemanticsCase ipVarName operandListVar (Map.Pair (Witness opc) (PairF semantics capInfo)) =
  match (conP (DT.capturedOpcodeName capInfo) []) (normalB (mkOperandListCase ipVarName operandListVar opc semantics capInfo)) []

-- | For each opcode case, we have a sub-case expression to destructure the
-- operand list into names that we can reference.  This generates an expression
-- of the form:
--
-- > case operandList of
-- >   op1 :> op2 :> op3 :> Nil -> ${BODY}
--
-- where ${BODY} is generated by 'genCaseBody', which references the operand
-- names introduced by this case (e.g., op1, op2, op3).  Those names are pulled
-- from the DT.CaptureInfo, and have been pre-allocated.  See
-- Dismantle.Tablegen.TH.Capture.captureInfo for information on how those names
-- are generated.
--
-- Note that the structure of the operand list is actually a little more
-- complicated than the above.  Each operand actually has an additional level of
-- wrapper around it, and really looks like:
--
-- >    Dismantle.PPC.ADD4
-- >      -> case operands_ayaa of {
-- >           (Gprc gprc0 :> (Gprc gprc1 :> (Gprc gprc2 :> Nil)))
-- >             -> ${BODY}
--
-- in an example with three general purpose register operands.
mkOperandListCase :: (L.Location arch ~ APPC.Location arch,
                      A.Architecture arch,
                      1 <= APPC.ArchRegWidth arch,
                      M.RegAddrWidth (PPCReg arch) ~ APPC.ArchRegWidth arch)
                  => Name
                  -> Name
                  -> a tp
                  -> ParameterizedFormula (Sym t) arch tp
                  -> DT.CaptureInfo c a tp
                  -> Q Exp
mkOperandListCase ipVarName operandListVar opc semantics capInfo = do
  body <- genCaseBody ipVarName opc semantics (DT.capturedOperandNames capInfo)
  DT.genCase capInfo operandListVar body

data BoundVarInterpretations arch t =
  BoundVarInterpretations { locVars :: Map.MapF (SI.BoundVar (Sym t)) (L.Location arch)
                          , opVars  :: Map.MapF (SI.BoundVar (Sym t)) (FreeParamF Name)
                          }

-- | This is the function that translates formulas (semantics) into expressions
-- that construct macaw terms.
--
-- The stub implementation is essentially
--
-- > undefined ipVar arg1 arg2
--
-- to avoid unused variable warnings.
--
-- The two maps (locVars and opVars) are crucial for translating parameterized
-- formulas into expressions.
genCaseBody :: forall a sh t arch
               . (L.Location arch ~ APPC.Location arch,
                  A.Architecture arch,
                  1 <= APPC.ArchRegWidth arch,
                  M.RegAddrWidth (PPCReg arch) ~ APPC.ArchRegWidth arch)
            => Name
            -> a sh
            -> ParameterizedFormula (Sym t) arch sh
            -> SL.ShapedList (FreeParamF Name) sh
            -> Q Exp
genCaseBody ipVarName _opc semantics varNames =
  translateFormula ipVarName semantics (BoundVarInterpretations locVarsMap opVarsMap) varNames
  where
    locVarsMap :: Map.MapF (SI.BoundVar (Sym t)) (L.Location arch)
    locVarsMap = Map.foldrWithKey (collectVarForLocation (Proxy @arch)) Map.empty (pfLiteralVars semantics)

    opVarsMap :: Map.MapF (SI.BoundVar (Sym t)) (FreeParamF Name)
    opVarsMap = SL.foldrFCIndexed (collectOperandVars varNames) Map.empty (pfOperandVars semantics)

collectVarForLocation :: forall tp arch proxy t
                       . proxy arch
                      -> L.Location arch tp
                      -> SI.BoundVar (Sym t) tp
                      -> Map.MapF (SI.BoundVar (Sym t)) (L.Location arch)
                      -> Map.MapF (SI.BoundVar (Sym t)) (L.Location arch)
collectVarForLocation _ loc bv = Map.insert bv loc

-- | Index variables that map to operands
--
-- We record the TH 'Name' for the 'SI.BoundVar' that stands in for each
-- operand.  The idea will be that we will look up bound variables in this map
-- to be able to compute a TH expression to refer to it.
--
-- We have to unwrap and rewrap the 'FreeParamF' because the type parameter
-- changes when we switch from 'BV.BoundVar' to 'SI.BoundVar'.  See the
-- SemMC.BoundVar module for information about the nature of that change
-- (basically, from 'Symbol' to BaseType).
collectOperandVars :: forall sh tp arch t
                    . SL.ShapedList (FreeParamF Name) sh
                   -> SL.Index sh tp
                   -> BV.BoundVar (Sym t) arch tp
                   -> Map.MapF (SI.BoundVar (Sym t)) (FreeParamF Name)
                   -> Map.MapF (SI.BoundVar (Sym t)) (FreeParamF Name)
collectOperandVars varNames ix (BV.BoundVar bv) m =
  case SL.indexShapedList varNames ix of
    FreeParamF name -> Map.insert bv (FreeParamF name) m

-- | Generate an implementation of 'execInstruction' that runs in the
-- 'PPCGenerator' monad.  We pass in both the original list of semantics files
-- along with the list of opcode info objects.  We can match them up using
-- equality on opcodes (via a MapF).  Generating a combined list up-front would
-- be ideal, but is difficult for various TH reasons (we can't call 'lift' on
-- all of the things we would need to for that).
--
-- The structure of the term produced is documented in 'instructionMatcher'
genExecInstruction :: (A.Architecture arch,
                       OrdF a,
                       ShowF a,
                       LF.LiftF a,
                       L.Location arch ~ APPC.Location arch,
                       1 <= APPC.ArchRegWidth arch,
                       M.RegAddrWidth (PPCReg arch) ~ APPC.ArchRegWidth arch)
                   => proxy arch
                   -> (forall sh . c sh C.:- BuildOperandList arch sh)
                   -- ^ A constraint implication to let us extract/weaken the
                   -- constraint in our 'Witness' to the required 'BuildOperandList'
                   -> [(Some (Witness c a), BS.ByteString)]
                   -- ^ A list of opcodes (with constraint information
                   -- witnessed) paired with the bytestrings containing their
                   -- semantics.  This comes from semmc.
                   -> [Some (DT.CaptureInfo c a)]
                   -- ^ Extra information for each opcode to let us generate
                   -- some TH to match them.  This comes from the semantics
                   -- definitions in semmc.
                   -> Q Exp
genExecInstruction _ impl semantics captureInfo = do
  Some ng <- runIO PN.newIONonceGenerator
  sym <- runIO (S.newSimpleBackend ng)
  formulas <- runIO (loadFormulas sym impl semantics)
  let formulasWithInfo = foldr (attachInfo formulas) Map.empty captureInfo
  instructionMatcher formulasWithInfo
  where
    attachInfo m0 (Some ci) m =
      let co = DT.capturedOpcode ci
      in case Map.lookup co m0 of
        Nothing -> m
        Just pf -> Map.insert co (PairF pf ci) m

-- SemMC.Formula: instantiateFormula

type Sym t = S.SimpleBackend t

type family FromCrucibleBaseType (btp :: S.BaseType) :: M.Type where
  FromCrucibleBaseType (S.BaseBVType w) = M.BVType w
  FromCrucibleBaseType (S.BaseBoolType) = M.BoolType

-- Add an expression in the PPCGenerator monad. This returns a Macaw value
-- corresponding to the added expression.
addExpr :: M.ArchConstraints ppc => Expr ppc ids tp -> PPCGenerator ppc ids (M.Value ppc ids tp)
addExpr expr = do
  case expr of
    ValueExpr val -> return val
    AppExpr app -> do
      assignment <- addAssignment (M.EvalApp app)
      return $ M.AssignedValue assignment

natReprTH :: M.NatRepr w -> Q Exp
natReprTH w = [| knownNat :: M.NatRepr $(litT (numTyLit (natValue w))) |]

natReprFromIntTH :: Int -> Q Exp
natReprFromIntTH i = [| knownNat :: M.NatRepr $(litT (numTyLit (fromIntegral i))) |]

-- | Sequence a list of monadic actions without constructing an intermediate
-- list structure
doSequenceQ :: [ExpQ] -> Q Exp
doSequenceQ = doE . map noBindS

translateFormula :: forall arch t sh .
                    (L.Location arch ~ APPC.Location arch,
                     A.Architecture arch,
                     1 <= APPC.ArchRegWidth arch,
                     M.RegAddrWidth (PPCReg arch) ~ APPC.ArchRegWidth arch)
                 => Name
                 -> ParameterizedFormula (Sym t) arch sh
                 -> BoundVarInterpretations arch t
                 -> SL.ShapedList (FreeParamF Name) sh
                 -> Q Exp
translateFormula ipVarName semantics interps varNames = do
  let exps = map translateDefinition (Map.toList (pfDefs semantics))
  [| Just $(doSequenceQ exps) |]
  where translateDefinition :: Map.Pair (Parameter arch sh) (S.SymExpr (Sym t))
                            -> Q Exp
        translateDefinition (Map.Pair param expr) = do
          case param of
            OperandParameter _w idx -> do
              let FreeParamF name = varNames `SL.indexShapedList` idx
              [| do val <- $(addEltTH interps expr)
                    let reg = toPPCReg $(varE name)
                    curPPCState . M.boundValue reg .= val
               |]
            LiteralParameter APPC.LocMem -> writeMemTH interps expr
            LiteralParameter loc -> do
              [| do val <- $(addEltTH interps expr)
                    curPPCState . M.boundValue $(locToRegTH (Proxy @arch) loc) .= val
               |]
            FunctionParameter str (WrappedOperand _ opIx) _w -> do
              let FreeParamF boundOperandName = SL.indexShapedList varNames opIx
              case lookup str (A.locationFuncInterpretation (Proxy @arch)) of
                Nothing -> [| error ("Function has no definition: " ++ show $(lift str)) |]
                Just fi -> do
                  [| do case $(varE (A.exprInterpName fi)) $(varE boundOperandName) of
                          Just reg -> do
                            val <- $(addEltTH interps expr)
                            curPPCState . M.boundValue (toPPCReg reg) .= val
                          Nothing -> error ("Invalid instruction form at " ++ show $(varE ipVarName))
                   |]

addEltTH :: forall arch t ctp .
            (L.Location arch ~ APPC.Location arch,
             A.Architecture arch,
             1 <= APPC.ArchRegWidth arch,
             M.RegAddrWidth (PPCReg arch) ~ APPC.ArchRegWidth arch)
         => BoundVarInterpretations arch t
         -> S.Elt t ctp
         -> Q Exp
addEltTH interps elt = case elt of
  S.BVElt w val _loc ->
    [| return (M.BVValue $(natReprTH w) $(lift val)) |]
  S.AppElt appElt -> do
    [| do expr <- $(crucAppToExprTH (S.appEltApp appElt) interps)
          addExpr expr
     |]
  S.BoundVarElt bVar ->
    case Map.lookup bVar (locVars interps) of
      Just loc -> [| getRegValue $(locToRegTH (Proxy @arch) loc) |]
      Nothing  ->
        case Map.lookup bVar (opVars interps) of
          Just (FreeParamF name) -> [| extractValue $(varE name) |]
          Nothing -> fail $ "bound var not found: " ++ show bVar
  S.NonceAppElt n -> evalNonceAppTH interps (S.nonceEltApp n)
  S.SemiRingLiteral {} -> [| error "SemiRingLiteral Elts are not supported" |]

symFnName :: S.SimpleSymFn t args ret -> String
symFnName = T.unpack . Sy.solverSymbolAsText . S.symFnName

writeMemTH :: forall arch t tp
            . (L.Location arch ~ APPC.Location arch,
                A.Architecture arch,
                1 <= APPC.ArchRegWidth arch,
                M.RegAddrWidth (PPCReg arch) ~ APPC.ArchRegWidth arch)
           => BoundVarInterpretations arch t
           -> S.Elt t tp
           -> Q Exp
writeMemTH bvi expr =
  case expr of
    S.NonceAppElt n ->
      case S.nonceEltApp n of
        S.FnApp symFn args
          | Just memWidth <- matchWriteMemWidth (symFnName symFn) ->
            case FC.toListFC Some args of
              [_, Some addr, Some val] ->
                [| do addrVal <- $(addEltTH bvi addr)
                      writtenVal <- $(addEltTH bvi val)
                      let memRepr = M.BVMemRepr $(natReprFromIntTH memWidth) M.BigEndian
                      addStmt (M.WriteMem addrVal memRepr writtenVal)
                 |]
              _ -> fail ("Invalid memory write expression: " ++ showF expr)
        _ -> fail ("Unexpected memory definition: " ++ showF expr)
    _ -> fail ("Unexpected memory definition: " ++ showF expr)

-- | Match a "write_mem" intrinsic and return the number of bytes written
matchWriteMemWidth :: String -> Maybe Int
matchWriteMemWidth s = do
  suffix <- L.stripPrefix "write_mem_" s
  (`div` 8) <$> readMaybe suffix

evalNonceAppTH :: forall arch t tp
                . (A.Architecture arch,
                   L.Location arch ~ APPC.Location arch,
                   1 <= APPC.ArchRegWidth arch,
                   M.RegAddrWidth (PPCReg arch) ~ APPC.ArchRegWidth arch)
               => BoundVarInterpretations arch t
               -> S.NonceApp t (S.Elt t) tp
               -> Q Exp
evalNonceAppTH bvi nonceApp =
  case nonceApp of
    S.FnApp symFn args -> do
      let fnName = symFnName symFn
      -- Recursively evaluate the arguments.  In the recursive evaluator, we
      -- expect two cases:
      --
      -- 1) The argument is a name (via S.BoundVarElt); we want to return a
      -- simple TH expression that just refers to that name
      --
      -- 2) The argument is another call, which we want to evaluate into a
      -- simple TH expression
      --
      -- 3) Otherwise, we can probably just call the standard evaluator on it
      -- (this will probably be the case for read_mem and the floating point
      -- functions)
      --
      -- At the top level (after cases 1 and 2), we need to call 'extractValue' *once*.
      case fnName of
        "ppc_is_r0" -> do
          case FC.toListFC Some args of
            [Some operand] -> do
              -- The operand can be either a variable (TH name bound from
              -- matching on the instruction operand list) or a call on such.
              case operand of
                S.BoundVarElt bv -> do
                  case Map.lookup bv (opVars bvi) of
                    Just (FreeParamF name) -> [| extractValue (PE.interpIsR0 $(varE name)) |]
                    Nothing -> fail ("bound var not found: " ++ show bv)
                S.NonceAppElt nonceApp' -> do
                  case S.nonceEltApp nonceApp' of
                    S.FnApp symFn' args' -> do
                      let recName = symFnName symFn'
                      case lookup recName (A.locationFuncInterpretation (Proxy @arch)) of
                        Nothing -> fail ("Unsupported UF: " ++ recName)
                        Just fi -> do
                          case FC.toListFC (asName fnName bvi) args' of
                            [] -> fail ("zero-argument uninterpreted functions are not supported: " ++ fnName)
                            argNames -> do
                              let call = appE (varE (A.exprInterpName fi)) $ foldr1 appE (map varE argNames)
                              [| extractValue (PE.interpIsR0 ($(call))) |]
                    _ -> fail ("Unsupported nonce app type")
                _ -> fail "Unsupported operand to ppc.is_r0"
            _ -> fail ("Invalid argument list for ppc.is_r0: " ++ showF args)
        _ | Just nBytes <- readMemBytes fnName -> do
            case FC.toListFC Some args of
              [_, Some addrElt] -> do
                -- read_mem has a shape such that we expect two arguments; the
                -- first is just a stand-in in the semantics to represent the
                -- memory.
                [| do let memRep = M.BVMemRepr (NR.knownNat :: NR.NatRepr $(litT (numTyLit (fromIntegral nBytes)))) M.BigEndian
                      addr <- $(addEltTH bvi addrElt)
                      assignment <- addAssignment (M.ReadMem addr memRep)
                      return (M.AssignedValue assignment)
                 |]
              _ -> fail ("Unexpected arguments to read_mem: " ++ showF args)
          | Just fpFunc <- elementaryFPName fnName -> floatingPointTH bvi fpFunc args
          | otherwise ->
            case lookup fnName (A.locationFuncInterpretation (Proxy @arch)) of
              Nothing -> [| error ("Unsupported UF: " ++ show $(litE (StringL fnName))) |]
              Just fi -> do
                -- args is an assignment that contains elts; we could just generate
                -- expressions that evaluate each one and then splat them into new names
                -- that we apply our name to.
                case FC.toListFC (asName fnName bvi) args of
                  [] -> fail ("zero-argument uninterpreted functions are not supported: " ++ fnName)
                  argNames -> do
                    let call = appE (varE (A.exprInterpName fi)) $ foldr1 appE (map varE argNames)
                    [| extractValue ($(call)) |]
    _ -> [| error "Unsupported NonceApp case" |]

elementaryFPName :: String -> Maybe String
elementaryFPName = L.stripPrefix "fp_"

floatingPointTH :: forall arch t f c
                 . (L.Location arch ~ APPC.Location arch,
                     A.Architecture arch,
                     1 <= APPC.ArchRegWidth arch,
                     M.RegAddrWidth (PPCReg arch) ~ APPC.ArchRegWidth arch,
                     FC.FoldableFC f)
                 => BoundVarInterpretations arch t
                 -> String
                 -> f (S.Elt t) c
                 -> Q Exp
floatingPointTH bvi fnName args =
  case FC.toListFC Some args of
    [Some a] ->
      case fnName of
        "round_single" ->
          [| do fpval <- $(addEltTH bvi a)
                addExpr (AppExpr (M.FPCvt M.DoubleFloatRepr fpval M.SingleFloatRepr))
           |]
        "abs" ->
          -- Note that fabs is only defined for doubles; the operation is the
          -- same for single and double precision on PPC, so there is only a
          -- single instruction.
          [| do fpval <- $(addEltTH bvi a)
                addExpr (AppExpr (M.FPAbs M.DoubleFloatRepr fpval))
           |]
        "negate64" ->
          [| do fpval <- $(addEltTH bvi a)
                addExpr (AppExpr (M.FPNeg M.DoubleFloatRepr fpval))
           |]
        "negate32" ->
          [| do fpval <- $(addEltTH bvi a)
                addExpr (AppExpr (M.FPNeg M.SingleFloatRepr fpval))
           |]
        _ -> fail ("Unsupported unary floating point intrinsic: " ++ fnName)
    [Some a, Some b] ->
      case fnName of
        "add64" ->
          [| do valA <- $(addEltTH bvi a)
                valB <- $(addEltTH bvi b)
                addExpr (AppExpr (M.FPAdd M.DoubleFloatRepr valA valB))
           |]
        "add32" ->
          [| do valA <- $(addEltTH bvi a)
                valB <- $(addEltTH bvi b)
                addExpr (AppExpr (M.FPAdd M.SingleFloatRepr valA valB))
           |]
        "sub64" ->
          [| do valA <- $(addEltTH bvi a)
                valB <- $(addEltTH bvi b)
                addExpr (AppExpr (M.FPSub M.DoubleFloatRepr valA valB))
           |]
        "sub32" ->
          [| do valA <- $(addEltTH bvi a)
                valB <- $(addEltTH bvi b)
                addExpr (AppExpr (M.FPSub M.SingleFloatRepr valA valB))
           |]
        "mul64" ->
          [| do valA <- $(addEltTH bvi a)
                valB <- $(addEltTH bvi b)
                addExpr (AppExpr (M.FPMul M.DoubleFloatRepr valA valB))
           |]
        "mul32" ->
          [| do valA <- $(addEltTH bvi a)
                valB <- $(addEltTH bvi b)
                addExpr (AppExpr (M.FPMul M.SingleFloatRepr valA valB))
           |]
        "div64" ->
          [| do valA <- $(addEltTH bvi a)
                valB <- $(addEltTH bvi b)
                addExpr (AppExpr (M.FPDiv M.DoubleFloatRepr valA valB))
           |]
        "div32" ->
          [| do valA <- $(addEltTH bvi a)
                valB <- $(addEltTH bvi b)
                addExpr (AppExpr (M.FPDiv M.SingleFloatRepr valA valB))
           |]
        _ -> fail ("Unsupported binary floating point intrinsic: " ++ fnName)
    [Some a, Some b, Some c] ->
      case fnName of
        "muladd64" ->
          -- FIXME: This is very wrong - we need a separate constructor for it
          -- a * c + b
          [| do valA <- $(addEltTH bvi a)
                valB <- $(addEltTH bvi b)
                valC <- $(addEltTH bvi c)
                prodVal <- addExpr (AppExpr (M.FPMul M.DoubleFloatRepr valA valC))
                addExpr (AppExpr (M.FPAdd M.DoubleFloatRepr prodVal valB))
           |]
        "muladd32" ->
          -- a * c + b
          [| do valA <- $(addEltTH bvi a)
                valB <- $(addEltTH bvi b)
                valC <- $(addEltTH bvi c)
                prodVal <- addExpr (AppExpr (M.FPMul M.SingleFloatRepr valA valC))
                addExpr (AppExpr (M.FPAdd M.SingleFloatRepr prodVal valB))
           |]
        _ -> fail ("Unsupported ternary floating point intrinsic: " ++ fnName)
    _ -> fail ("Unsupported floating point intrinsic: " ++ fnName)

-- | Parse the name of a memory read intrinsic and return the number of bytes
-- that it reads.  For example
--
-- > readMemBytes "read_mem_8" == Just 1
readMemBytes :: String -> Maybe Int
readMemBytes s = do
  nBitsStr <- L.stripPrefix "read_mem_" s
  nBits <- readMaybe nBitsStr
  return (nBits `div` 8)

asName :: String -> BoundVarInterpretations arch t -> S.Elt t tp -> Name
asName ufName bvInterps elt =
  case elt of
    S.BoundVarElt bVar ->
      case Map.lookup bVar (opVars bvInterps) of
        Nothing -> error ("Expected " ++ show bVar ++ " to have an interpretation")
        Just (FreeParamF name) -> name
    _ -> error ("Unexpected elt as name (" ++ showF elt ++ ") in " ++ ufName)

-- Unimplemented:

-- Don't need to implement:
--   - all SemiRing operations (not using)
--   - all "Basic arithmetic operations" (not using)
--   - all "Operations that introduce irrational numbers" (not using)
--   - BVUnaryTerm (not using)
--   - all array operations (probably not using)
--   - all conversions
--   - all complex operations
--   - all structs

-- Might need to implement later:
--   - BVUdiv, BVUrem, BVSdiv, BVSrem
crucAppToExprTH :: (L.Location arch ~ APPC.Location arch,
                    A.Architecture arch,
                   1 <= APPC.ArchRegWidth arch,
                   M.RegAddrWidth (PPCReg arch) ~ APPC.ArchRegWidth arch)
                => S.App (S.Elt t) ctp
                -> BoundVarInterpretations arch t
                -> Q Exp
crucAppToExprTH elt interps = case elt of
  S.TrueBool  -> [| return $ ValueExpr (M.BoolValue True) |]
  S.FalseBool -> [| return $ ValueExpr (M.BoolValue False) |]
  S.NotBool bool ->
    [| do bval <- $(addEltTH interps bool)
          return (AppExpr (M.NotApp bval))
     |]
  S.AndBool bool1 bool2 ->
    [| do bval1 <- $(addEltTH interps bool1)
          bval2 <- $(addEltTH interps bool2)
          return (AppExpr (M.AndApp bval1 bval2))
     |]
  S.XorBool bool1 bool2 ->
    [| do bval1 <- $(addEltTH interps bool1)
          bval2 <- $(addEltTH interps bool2)
          return (AppExpr (M.XorApp bval1 bval2))
     |]
  S.IteBool test t f ->
    [| do testVal <- $(addEltTH interps test)
          tval <- $(addEltTH interps t)
          fval <- $(addEltTH interps f)
          return (AppExpr (M.Mux M.BoolTypeRepr testVal tval fval))
     |]
  S.BVIte w numBranches test t f ->
    [| do let rep = $(natReprTH w)
          testVal <- $(addEltTH interps test)
          tval <- $(addEltTH interps t)
          fval <- $(addEltTH interps f)
          return (AppExpr (M.Mux (M.BVTypeRepr rep) testVal tval fval))
     |]
  S.BVEq bv1 bv2 ->
    [| do bval1 <- $(addEltTH interps bv1)
          bval2 <- $(addEltTH interps bv2)
          return (AppExpr (M.Eq bval1 bval2))
     |]
  S.BVSlt bv1 bv2 ->
    [| do bval1 <- $(addEltTH interps bv1)
          bval2 <- $(addEltTH interps bv2)
          return (AppExpr (M.BVSignedLt bval1 bval2))
     |]
  S.BVUlt bv1 bv2 ->
    [| do bval1 <- $(addEltTH interps bv1)
          bval2 <- $(addEltTH interps bv2)
          return (AppExpr (M.BVUnsignedLt bval1 bval2))
     |]
  S.BVConcat w bv1 bv2 -> do
    let u = S.bvWidth bv1
        v = S.bvWidth bv2
    [| do bv1Val <- $(addEltTH interps bv1)
          bv2Val <- $(addEltTH interps bv2)
          S.LeqProof <- return $ S.leqAdd2 (S.leqRefl $(natReprTH u)) (S.leqProof (knownNat @1) $(natReprTH v))
          pf1@S.LeqProof <- return $ S.leqAdd2 (S.leqRefl $(natReprTH v)) (S.leqProof (knownNat @1) $(natReprTH u))
          Refl <- return $ S.plusComm $(natReprTH u) $(natReprTH v)
          S.LeqProof <- return (S.leqTrans pf1 (S.leqRefl $(natReprTH w)))
          bv1Ext <- addExpr (AppExpr (M.UExt bv1Val $(natReprTH w)))
          bv2Ext <- addExpr (AppExpr (M.UExt bv2Val $(natReprTH w)))
          bv1Shifter <- addExpr (ValueExpr (M.BVValue $(natReprTH w) (natValue $(natReprTH v))))
          bv1Shf <- addExpr (AppExpr (M.BVShl $(natReprTH w) bv1Ext bv1Shifter))
          return $ AppExpr (M.BVOr $(natReprTH w) bv1Shf bv2Ext)
     |]
  S.BVSelect idx n bv -> do
    let w = S.bvWidth bv
    case natValue n + 1 <= natValue w of
      True ->
        [| do bvVal <- $(addEltTH interps bv)
              Just S.LeqProof <- return $ S.testLeq ($(natReprTH n) `addNat` (knownNat @1)) $(natReprTH w)
              pf1@S.LeqProof <- return $ S.leqAdd2 (S.leqRefl $(natReprTH idx)) (S.leqProof (knownNat @1) $(natReprTH n))
              pf2@S.LeqProof <- return $ S.leqAdd (S.leqRefl (knownNat @1)) $(natReprTH idx)
              Refl <- return $ S.plusComm (knownNat @1) $(natReprTH idx)
              pf3@S.LeqProof <- return $ S.leqTrans pf2 pf1
              S.LeqProof <- return $ S.leqTrans pf3 (S.leqProof ($(natReprTH idx) `addNat` $(natReprTH n)) $(natReprTH w))
              bvShf <- addExpr (AppExpr (M.BVShr $(natReprTH w) bvVal (M.mkLit $(natReprTH w) (natValue $(natReprTH idx)))))
              -- return $ ValueExpr (M.mkLit $(natReprTH n) 1)
              return $ AppExpr (M.Trunc bvShf $(natReprTH n))
         |]
      False -> [| do Just Refl <- return $ testEquality $(natReprTH n) $(natReprTH w)
                     return $ ValueExpr bvVal
                |]
  S.BVNeg w bv -> do
    -- Note: This is still untested
    [| do bvVal <- $(addEltTH interps bv)
          bvComp <- addExpr (AppExpr (M.BVComplement $(natReprTH w) bvVal))
          return $ AppExpr (M.BVAdd $(natReprTH w) bvComp (M.mkLit $(natReprTH w) 1))
     |]
  S.BVTestBit idx bv ->
    -- Note: below is untested, could be wrong.
    [| do bitExpVal <- addExpr (ValueExpr (M.BVValue $(natReprTH (S.bvWidth bv)) $(lift idx)))
          bval <- $(addEltTH interps bv)
          return (AppExpr (M.BVTestBit bitExpVal bval))
     |]
  S.BVAdd w bv1 bv2 ->
    [| do let rep = $(natReprTH w)
          bval1 <- $(addEltTH interps bv1)
          bval2 <- $(addEltTH interps bv2)
          return (AppExpr (M.BVAdd rep bval1 bval2))
     |]
  S.BVMul w bv1 bv2 ->
    [| do let rep = $(natReprTH w)
          bval1 <- $(addEltTH interps bv1)
          bval2 <- $(addEltTH interps bv2)
          return (AppExpr (M.BVMul rep bval1 bval2))
     |]
  S.BVShl w bv1 bv2 ->
    [| do let rep = $(natReprTH w)
          bval1 <- $(addEltTH interps bv1)
          bval2 <- $(addEltTH interps bv2)
          return (AppExpr (M.BVShl rep bval1 bval2))
     |]
  S.BVLshr w bv1 bv2 ->
    [| do let rep = $(natReprTH w)
          bval1 <- $(addEltTH interps bv1)
          bval2 <- $(addEltTH interps bv2)
          return (AppExpr (M.BVShr rep bval1 bval2))
     |]
  S.BVAshr w bv1 bv2 ->
    [| do let rep = $(natReprTH w)
          bval1 <- $(addEltTH interps bv1)
          bval2 <- $(addEltTH interps bv2)
          return (AppExpr (M.BVSar rep bval1 bval2))
     |]
  S.BVZext w bv ->
    [| do bval <- $(addEltTH interps bv)
          let rep = $(natReprTH w)
          return (AppExpr (M.UExt bval rep))
     |]
  S.BVSext w bv ->
    [| do bval <- $(addEltTH interps bv)
          let rep = $(natReprTH w)
          return (AppExpr (M.SExt bval rep))
     |]
  S.BVTrunc w bv ->
    [| do bval <- $(addEltTH interps bv)
          let rep = $(natReprTH w)
          return (AppExpr (M.Trunc bval rep))
     |]
  S.BVBitNot w bv ->
    [| do let rep = $(natReprTH w)
          bval <- $(addEltTH interps bv)
          return (AppExpr (M.BVComplement rep bval))
     |]
  S.BVBitAnd w bv1 bv2 ->
    [| do let rep = $(natReprTH w)
          bval1 <- $(addEltTH interps bv1)
          bval2 <- $(addEltTH interps bv2)
          return (AppExpr (M.BVAnd rep bval1 bval2))
     |]
  S.BVBitOr w bv1 bv2 ->
    [| do let rep = $(natReprTH w)
          bval1 <- $(addEltTH interps bv1)
          bval2 <- $(addEltTH interps bv2)
          return (AppExpr (M.BVOr rep bval1 bval2))
     |]
  S.BVBitXor w bv1 bv2 ->
    [| do let rep = $(natReprTH w)
          bval1 <- $(addEltTH interps bv1)
          bval2 <- $(addEltTH interps bv2)
          return (AppExpr (M.BVXor rep bval1 bval2))
     |]
  _ -> [| error "unsupported Crucible elt" |]



crucAppToExpr :: (M.ArchConstraints ppc) => S.App (S.Elt t) ctp -> PPCGenerator ppc ids (Expr ppc ids (FromCrucibleBaseType ctp))
crucAppToExpr S.TrueBool  = return $ ValueExpr (M.BoolValue True)
crucAppToExpr S.FalseBool = return $ ValueExpr (M.BoolValue False)
crucAppToExpr (S.NotBool bool) = (AppExpr . M.NotApp) <$> addElt bool
crucAppToExpr (S.AndBool bool1 bool2) = AppExpr <$> do
  M.AndApp <$> addElt bool1 <*> addElt bool2
crucAppToExpr (S.XorBool bool1 bool2) = AppExpr <$> do
  M.XorApp <$> addElt bool1 <*> addElt bool2
crucAppToExpr (S.IteBool test t f) = AppExpr <$> do
  M.Mux <$> pure M.BoolTypeRepr <*> addElt test <*> addElt t <*> addElt f
crucAppToExpr (S.BVIte w numBranches test t f) = AppExpr <$> do -- what is numBranches for?
  M.Mux <$> pure (M.BVTypeRepr w) <*> addElt test <*> addElt t <*> addElt f
crucAppToExpr (S.BVEq bv1 bv2) = AppExpr <$> do
  M.Eq <$> addElt bv1 <*> addElt bv2
crucAppToExpr (S.BVSlt bv1 bv2) = AppExpr <$> do
  M.BVSignedLt <$> addElt bv1 <*> addElt bv2
crucAppToExpr (S.BVUlt bv1 bv2) = AppExpr <$> do
  M.BVUnsignedLt <$> addElt bv1 <*> addElt bv2
crucAppToExpr (S.BVConcat w bv1 bv2) = AppExpr <$> do
  let u = S.bvWidth bv1
      v = S.bvWidth bv2
  bv1Val <- addElt bv1
  bv2Val <- addElt bv2
  S.LeqProof <- return $ S.leqAdd2 (S.leqRefl u) (S.leqProof (knownNat @1) v)
  pf1@S.LeqProof <- return $ S.leqAdd2 (S.leqRefl v) (S.leqProof (knownNat @1) u)
  Refl <- return $ S.plusComm u v
  S.LeqProof <- return $ S.leqTrans pf1 (S.leqRefl w)
  bv1Ext <- addExpr (AppExpr (M.UExt bv1Val w)) ---(u `addNat` v)))
  bv2Ext <- addExpr (AppExpr (M.UExt bv2Val w))
  bv1Shifter <- addExpr (ValueExpr (M.BVValue w (natValue v)))
  bv1Shf <- addExpr (AppExpr (M.BVShl w bv1Ext bv1Shifter))
  return $ M.BVOr w bv1Shf bv2Ext
crucAppToExpr (S.BVSelect idx n bv) = do
  let w = S.bvWidth bv
  bvVal <- addElt bv
  case natValue n + 1 <= natValue w of
    True -> do
      -- Is there a way to just "know" that n + 1 <= w?
      Just S.LeqProof <- return $ S.testLeq (n `addNat` (knownNat @1)) w
      pf1@S.LeqProof <- return $ S.leqAdd2 (S.leqRefl idx) (S.leqProof (knownNat @1) n)
      pf2@S.LeqProof <- return $ S.leqAdd (S.leqRefl (knownNat @1)) idx
      Refl <- return $ S.plusComm (knownNat @1) idx
      pf3@S.LeqProof <- return $ S.leqTrans pf2 pf1
      S.LeqProof <- return $ S.leqTrans pf3 (S.leqProof (idx `addNat` n) w)
      bvShf <- addExpr (AppExpr (M.BVShr w bvVal (M.mkLit w (natValue idx))))
      return $ AppExpr (M.Trunc bvShf n)
    False -> do
      -- Is there a way to just "know" that n = w?
      Just Refl <- return $ testEquality n w
      return $ ValueExpr bvVal
crucAppToExpr (S.BVNeg w bv) = do
  bvVal  <- addElt bv
  bvComp <- addExpr (AppExpr (M.BVComplement w bvVal))
  return $ AppExpr (M.BVAdd w bvComp (M.mkLit w 1))
crucAppToExpr (S.BVTestBit idx bv) = AppExpr <$> do
  M.BVTestBit
    <$> addExpr (ValueExpr (M.BVValue (S.bvWidth bv) (fromIntegral idx)))
    <*> addElt bv
crucAppToExpr (S.BVAdd repr bv1 bv2) = AppExpr <$> do
  M.BVAdd <$> pure repr <*> addElt bv1 <*> addElt bv2
crucAppToExpr (S.BVMul repr bv1 bv2) = AppExpr <$> do
  M.BVMul <$> pure repr <*> addElt bv1 <*> addElt bv2
crucAppToExpr (S.BVShl repr bv1 bv2) = AppExpr <$> do
  M.BVShl <$> pure repr <*> addElt bv1 <*> addElt bv2
crucAppToExpr (S.BVLshr repr bv1 bv2) = AppExpr <$> do
  M.BVShr <$> pure repr <*> addElt bv1 <*> addElt bv2
crucAppToExpr (S.BVAshr repr bv1 bv2) = AppExpr <$> do
  M.BVSar <$> pure repr <*> addElt bv1 <*> addElt bv2
crucAppToExpr (S.BVZext repr bv) = AppExpr <$> do
  M.UExt <$> addElt bv <*> pure repr
crucAppToExpr (S.BVSext repr bv) = AppExpr <$> do
  M.SExt <$> addElt bv <*> pure repr
crucAppToExpr (S.BVTrunc repr bv) = AppExpr <$> do
  M.Trunc <$> addElt bv <*> pure repr
crucAppToExpr (S.BVBitNot repr bv) = AppExpr <$> do
  M.BVComplement <$> pure repr <*> addElt bv
crucAppToExpr (S.BVBitAnd repr bv1 bv2) = AppExpr <$> do
  M.BVAnd <$> pure repr <*> addElt bv1 <*> addElt bv2
crucAppToExpr (S.BVBitOr repr bv1 bv2) = AppExpr <$> do
  M.BVOr <$> pure repr <*> addElt bv1 <*> addElt bv2
crucAppToExpr (S.BVBitXor repr bv1 bv2) = AppExpr <$> do
  M.BVXor <$> pure repr <*> addElt bv1 <*> addElt bv2
crucAppToExpr _ = error "crucAppToExpr: unimplemented crucible operation"


locToReg :: (1 <= APPC.ArchRegWidth ppc,
             M.RegAddrWidth (PPCReg ppc) ~ APPC.ArchRegWidth ppc)
         => proxy ppc
         -> APPC.Location ppc ctp
         -> PPCReg ppc (FromCrucibleBaseType ctp)
locToReg _ (APPC.LocGPR gpr) = PPC_GP gpr
locToReg _  APPC.LocIP       = PPC_IP
locToReg _  APPC.LocLNK      = PPC_LNK
locToReg _  APPC.LocCTR      = PPC_CTR
locToReg _  APPC.LocCR       = PPC_CR
locToReg _  _                = undefined
-- fill the rest out later

locToRegTH :: (1 <= APPC.ArchRegWidth ppc,
               M.RegAddrWidth (PPCReg ppc) ~ APPC.ArchRegWidth ppc)
           => proxy ppc
           -> APPC.Location ppc ctp
           -> Q Exp
locToRegTH _ (APPC.LocGPR (D.GPR gpr)) = [| PPC_GP (D.GPR $(lift gpr)) |]
locToRegTH _  APPC.LocIP       = [| PPC_IP |]
locToRegTH _  APPC.LocLNK      = [| PPC_LNK |]
locToRegTH _  APPC.LocCTR      = [| PPC_CTR |]
locToRegTH _  APPC.LocCR       = [| PPC_CR |]
locToRegTH _  APPC.LocXER      = [| PPC_XER |]
locToRegTH _  loc              = [| undefined |]
-- fill the rest out later

-- | Given a location to modify and a crucible formula, construct a PPCGenerator that
-- will modify the location by the function encoded in the formula.
interpretFormula :: forall ppc t ctp s .
                    (1 <= APPC.ArchRegWidth ppc,
                     M.RegAddrWidth (PPCReg ppc) ~ APPC.ArchRegWidth ppc,
                     M.ArchConstraints ppc)
                 => APPC.Location ppc ctp
                 -> S.Elt t ctp
                 -> PPCGenerator ppc s ()
interpretFormula loc elt = do
  expr <- eltToExpr elt
  let reg  = (locToReg (Proxy @ppc) loc)
  case expr of
    ValueExpr val -> curPPCState . M.boundValue reg .= val
    AppExpr app -> do
      assignment <- addAssignment (M.EvalApp app)
      curPPCState . M.boundValue reg .= M.AssignedValue assignment

-- Convert a Crucible element into an expression.
eltToExpr :: M.ArchConstraints ppc => S.Elt t ctp -> PPCGenerator ppc ids (Expr ppc ids (FromCrucibleBaseType ctp))
eltToExpr (S.BVElt w val loc) = return $ ValueExpr (M.BVValue w val)
eltToExpr (S.AppElt appElt) = crucAppToExpr (S.appEltApp appElt)
eltToExpr (S.BoundVarElt sbv) = undefined

-- Add a Crucible element in the PPCGenerator monad.
addElt :: M.ArchConstraints ppc => S.Elt t ctp -> PPCGenerator ppc ids (M.Value ppc ids (FromCrucibleBaseType ctp))
addElt elt = eltToExpr elt >>= addExpr

addElt' :: M.ArchConstraints ppc => S.Elt t ctp -> PPCGenerator ppc ids (M.Value ppc ids (FromCrucibleBaseType ctp))
addElt' elt = case elt of
  S.BVElt w val loc -> return $ M.BVValue w val
  S.AppElt appElt   -> do x <- crucAppToExpr (S.appEltApp appElt)
                          addExpr x
  S.BoundVarElt sbv -> undefined
