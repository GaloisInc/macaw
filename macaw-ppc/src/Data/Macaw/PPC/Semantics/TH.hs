{-# LANGUAGE DataKinds #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE TypeApplications #-}

module Data.Macaw.PPC.Semantics.TH
  ( genExecInstruction
  ) where

import qualified Data.ByteString as BS
import qualified Data.Constraint as C

import Control.Lens
import Data.Proxy
import Language.Haskell.TH
import Language.Haskell.TH.Syntax
import GHC.TypeLits

import           Data.Parameterized.Classes
import           Data.Parameterized.FreeParamF ( FreeParamF(..) )
import qualified Data.Parameterized.Lift as LF
import qualified Data.Parameterized.Map as Map
import qualified Data.Parameterized.Nonce as PN
import qualified Data.Parameterized.ShapedList as SL
import           Data.Parameterized.Some ( Some(..) )
import qualified Data.Parameterized.TraversableFC as FC
import           Data.Parameterized.Witness ( Witness(..) )
import qualified Lang.Crucible.Solver.Interface as SI
import qualified Lang.Crucible.Solver.SimpleBuilder as S
import qualified Lang.Crucible.Solver.SimpleBackend as S
import qualified Lang.Crucible.BaseTypes as S

import qualified Dismantle.PPC as D
import qualified Dismantle.Tablegen.TH.Capture as DT

import qualified SemMC.BoundVar as BV
import           SemMC.Formula
import qualified SemMC.Architecture as A
import qualified SemMC.Architecture.Location as L
import qualified SemMC.Architecture.PPC.Location as APPC
import qualified Data.Macaw.CFG as M
import qualified Data.Macaw.Types as M

import Data.Parameterized.NatRepr ( knownNat
                                  , addNat
                                  , natValue
                                  , isPosNat
                                  , testLeq
                                  )

import Data.Macaw.PPC.Generator
import Data.Macaw.PPC.PPCReg

-- run stack with --ghc-options=-ddump-splices

-- | A different parameterized pair wrapper; the one in Data.Parameterized.Map
-- hides the @tp@ parameter under an existential, while we need the variant that
-- exposes it.
data PairF a b tp = PairF (a tp) (b tp)

-- | Generate the top-level lambda with a case expression over an instruction
-- (casing on opcode)
--
-- > \ipVar (Instruction opcode operandList) ->
-- >   case opcode of
-- >     ${CASES}
--
-- where each case in ${CASES} is defined by 'mkSemanticsCase'; each case
-- matches one opcode.
instructionMatcher :: (OrdF a, LF.LiftF a,
                       L.Location arch ~ APPC.Location arch,
                       1 <= APPC.ArchRegWidth arch,
                       M.RegAddrWidth (PPCReg arch) ~ APPC.ArchRegWidth arch)
                   => Map.MapF (Witness c a) (PairF (ParameterizedFormula (Sym t) arch) (DT.CaptureInfo c a))
                   -> Q Exp
instructionMatcher formulas = do
  ipVarName <- newName "ipVal"
  opcodeVar <- newName "opcode"
  operandListVar <- newName "operands"
  let cases = map (mkSemanticsCase ipVarName operandListVar) (Map.toList formulas)
  lamE [varP ipVarName, conP 'D.Instruction [varP opcodeVar, varP operandListVar]] (caseE (varE opcodeVar) cases)

-- | Generate a single case for one opcode of the case expression.
--
-- > ADD4 -> ${BODY}
--
-- where the ${BODY} is generated by 'mkOperandListCase'
mkSemanticsCase :: (LF.LiftF a,
                    L.Location arch ~ APPC.Location arch,
                    1 <= APPC.ArchRegWidth arch,
                    M.RegAddrWidth (PPCReg arch) ~ APPC.ArchRegWidth arch)
                => Name
                -> Name
                -> Map.Pair (Witness c a) (PairF (ParameterizedFormula (Sym t) arch) (DT.CaptureInfo c a))
                -> MatchQ
mkSemanticsCase ipVarName operandListVar (Map.Pair (Witness opc) (PairF semantics capInfo)) =
  match (conP (DT.capturedOpcodeName capInfo) []) (normalB (mkOperandListCase ipVarName operandListVar opc semantics capInfo)) []

-- | For each opcode case, we have a sub-case expression to destructure the
-- operand list into names that we can reference.  This generates an expression
-- of the form:
--
-- > case operandList of
-- >   op1 :> op2 :> op3 :> Nil -> ${BODY}
--
-- where ${BODY} is generated by 'genCaseBody', which references the operand
-- names introduced by this case (e.g., op1, op2, op3).  Those names are pulled
-- from the DT.CaptureInfo, and have been pre-allocated.  See
-- Dismantle.Tablegen.TH.Capture.captureInfo for information on how those names
-- are generated.
--
-- Note that the structure of the operand list is actually a little more
-- complicated than the above.  Each operand actually has an additional level of
-- wrapper around it, and really looks like:
--
-- >    Dismantle.PPC.ADD4
-- >      -> case operands_ayaa of {
-- >           (Gprc gprc0 :> (Gprc gprc1 :> (Gprc gprc2 :> Nil)))
-- >             -> ${BODY}
--
-- in an example with three general purpose register operands.
mkOperandListCase :: (L.Location arch ~ APPC.Location arch,
                      1 <= APPC.ArchRegWidth arch,
                      M.RegAddrWidth (PPCReg arch) ~ APPC.ArchRegWidth arch)
                  => Name
                  -> Name
                  -> a tp
                  -> ParameterizedFormula (Sym t) arch tp
                  -> DT.CaptureInfo c a tp
                  -> Q Exp
mkOperandListCase ipVarName operandListVar opc semantics capInfo = do
  body <- genCaseBody ipVarName opc semantics (DT.capturedOperandNames capInfo)
  DT.genCase capInfo operandListVar body

-- | This is the function that translates formulas (semantics) into expressions
-- that construct macaw terms.
--
-- The stub implementation is essentially
--
-- > undefined ipVar arg1 arg2
--
-- to avoid unused variable warnings.
--
-- The two maps (locVars and opVars) are crucial for translating parameterized
-- formulas into expressions.
genCaseBody :: forall a sh t arch
               . (L.Location arch ~ APPC.Location arch,
                  1 <= APPC.ArchRegWidth arch,
                  M.RegAddrWidth (PPCReg arch) ~ APPC.ArchRegWidth arch)
            => Name
            -> a sh
            -> ParameterizedFormula (Sym t) arch sh
            -> SL.ShapedList (FreeParamF Name) sh
            -> Q Exp
genCaseBody ipVarName opc semantics varNames =
  translateFormula semantics locVars opVars
  where
    binders = ipVarName : FC.toListFC unFreeParamF varNames

    locVars :: Map.MapF (SI.BoundVar (Sym t)) (L.Location arch)
    locVars = Map.foldrWithKey (collectVarForLocation (Proxy @arch)) Map.empty (pfLiteralVars semantics)

    opVars :: Map.MapF (SI.BoundVar (Sym t)) (FreeParamF Name)
    opVars = SL.foldrFCIndexed (collectOperandVars varNames) Map.empty (pfOperandVars semantics)

collectVarForLocation :: forall tp arch proxy t
                       . proxy arch
                      -> L.Location arch tp
                      -> SI.BoundVar (Sym t) tp
                      -> Map.MapF (SI.BoundVar (Sym t)) (L.Location arch)
                      -> Map.MapF (SI.BoundVar (Sym t)) (L.Location arch)
collectVarForLocation _ loc bv = Map.insert bv loc

-- | Index variables that map to operands
--
-- We record the TH 'Name' for the 'SI.BoundVar' that stands in for each
-- operand.  The idea will be that we will look up bound variables in this map
-- to be able to compute a TH expression to refer to it.
--
-- We have to unwrap and rewrap the 'FreeParamF' because the type parameter
-- changes when we switch from 'BV.BoundVar' to 'SI.BoundVar'.  See the
-- SemMC.BoundVar module for information about the nature of that change
-- (basically, from 'Symbol' to BaseType).
collectOperandVars :: forall sh tp arch t
                    . SL.ShapedList (FreeParamF Name) sh
                   -> SL.Index sh tp
                   -> BV.BoundVar (Sym t) arch tp
                   -> Map.MapF (SI.BoundVar (Sym t)) (FreeParamF Name)
                   -> Map.MapF (SI.BoundVar (Sym t)) (FreeParamF Name)
collectOperandVars varNames ix (BV.BoundVar bv) m =
  case SL.indexShapedList varNames ix of
    FreeParamF name -> Map.insert bv (FreeParamF name) m

-- | Generate an implementation of 'execInstruction' that runs in the
-- 'PPCGenerator' monad.  We pass in both the original list of semantics files
-- along with the list of opcode info objects.  We can match them up using
-- equality on opcodes (via a MapF).  Generating a combined list up-front would
-- be ideal, but is difficult for various TH reasons (we can't call 'lift' on
-- all of the things we would need to for that).
--
-- The structure of the term produced is documented in 'instructionMatcher'
genExecInstruction :: (A.Architecture arch,
                       OrdF a,
                       ShowF a,
                       LF.LiftF a,
                       L.Location arch ~ APPC.Location arch,
                       1 <= APPC.ArchRegWidth arch,
                       M.RegAddrWidth (PPCReg arch) ~ APPC.ArchRegWidth arch)
                   => proxy arch
                   -> (forall sh . c sh C.:- BuildOperandList arch sh)
                   -- ^ A constraint implication to let us extract/weaken the
                   -- constraint in our 'Witness' to the required 'BuildOperandList'
                   -> [(Some (Witness c a), BS.ByteString)]
                   -- ^ A list of opcodes (with constraint information
                   -- witnessed) paired with the bytestrings containing their
                   -- semantics.  This comes from semmc.
                   -> [Some (DT.CaptureInfo c a)]
                   -- ^ Extra information for each opcode to let us generate
                   -- some TH to match them.  This comes from the semantics
                   -- definitions in semmc.
                   -> Q Exp
genExecInstruction _ impl semantics captureInfo = do
  Some ng <- runIO PN.newIONonceGenerator
  sym <- runIO (S.newSimpleBackend ng)
  formulas <- runIO (loadFormulas sym impl semantics)
  let formulasWithInfo = foldr (attachInfo formulas) Map.empty captureInfo
  instructionMatcher formulasWithInfo
  where
    attachInfo m0 (Some ci) m =
      let co = DT.capturedOpcode ci
      in case Map.lookup co m0 of
        Nothing -> m
        Just pf -> Map.insert co (PairF pf ci) m

-- SemMC.Formula: instantiateFormula

type Sym t = S.SimpleBackend t

type family FromCrucibleBaseType (btp :: S.BaseType) :: M.Type where
  FromCrucibleBaseType (S.BaseBVType w) = M.BVType w
  FromCrucibleBaseType (S.BaseBoolType) = M.BoolType

-- Unimplemented:

-- Don't need to implement:
--   - all SemiRing operations (not using)
--   - all "Basic arithmetic operations" (not using)
--   - all "Operations that introduce irrational numbers" (not using)
--   - BVUnaryTerm (not using)
--   - all array operations (probably not using)
--   - all conversions
--   - all complex operations
--   - all structs

-- Might need to implement later:
--   - BVUdiv, BVUrem, BVSdiv, BVSrem

addExpr :: Expr ppc ids tp -> PPCGenerator ppc ids (M.Value ppc ids tp)
addExpr expr = do
  case expr of
    ValueExpr val -> return val
    AppExpr app -> do
      assignment <- addAssignment (M.EvalApp app)
      return $ M.AssignedValue assignment

-- This function needs to be written.
addExprTH :: Expr ppc ids tp -> Q Exp
addExprTH expr = case expr of
  ValueExpr val -> [| undefined |]
  AppExpr app -> [| undefined |]

addElt :: S.Elt t ctp -> PPCGenerator ppc ids (M.Value ppc ids (FromCrucibleBaseType ctp))
addElt elt = eltToExpr elt >>= addExpr

-- combine this with addElt
eltToExpr :: S.Elt t ctp -> PPCGenerator ppc ids (Expr ppc ids (FromCrucibleBaseType ctp))
eltToExpr (S.BVElt w val loc) = return $ ValueExpr (M.BVValue w val)
eltToExpr (S.AppElt appElt) = crucAppToExpr (S.appEltApp appElt)
eltToExpr (S.BoundVarElt sbv) = undefined

addElt' :: S.Elt t ctp -> PPCGenerator ppc ids (M.Value ppc ids (FromCrucibleBaseType ctp))
addElt' elt = case elt of
  S.BVElt w val loc -> return $ M.BVValue w val
  S.AppElt appElt   -> do x <- crucAppToExpr (S.appEltApp appElt)
                          addExpr x
  S.BoundVarElt sbv -> undefined

natReprTH :: M.NatRepr w -> Q Exp
natReprTH w = [| knownNat :: M.NatRepr $(litT (return $ NumTyLit (natValue w))) |]

translateFormula :: forall arch t sh .
                    (L.Location arch ~ APPC.Location arch,
                     1 <= APPC.ArchRegWidth arch,
                     M.RegAddrWidth (PPCReg arch) ~ APPC.ArchRegWidth arch)
                 => ParameterizedFormula (Sym t) arch sh
                 -> Map.MapF (SI.BoundVar (Sym t)) (L.Location arch)
                 -> Map.MapF (SI.BoundVar (Sym t)) (FreeParamF Name)
                 -> Q Exp
translateFormula semantics locVars opVars = do
  let exps = map translateDefinition (Map.toList (pfDefs semantics))
  [| Just (sequence_ $(listE exps)) |]
  where translateDefinition :: Map.Pair (Parameter arch sh) (S.SymExpr (Sym t))
                            -> Q Exp
        translateDefinition (Map.Pair param expr) = do
          case param of
            OperandParameter w idx -> [| undefined |]
            LiteralParameter loc -> do
              e <- addEltTH expr
              reg <- locToRegTH (Proxy @arch) loc
              [| do val <- $(return e)
                    curPPCState . M.boundValue $(return reg) .= val
                    -- case c of
                    --   ValueExpr val -> curPPCState . M.boundValue $(return reg) .= val
                    --   AppExpr app -> do
                    --     assignment <- addAssignment (M.EvalApp app)
                    --     curPPCState . M.boundValue $(return reg) .= M.AssignedValue assignment
               |]
            FunctionParameter str operand w -> [| undefined |]

addEltTH :: S.Elt t ctp -> Q Exp
addEltTH elt = case elt of
  S.BVElt w val loc ->
    [| return (M.BVValue $(natReprTH w) $(lift val)) |]
  S.AppElt appElt -> do
    let app = S.appEltApp appElt
    appExpr <- crucAppToExprTH app
    [| $(crucAppToExprTH (S.appEltApp appElt)) >>= addExpr |]
  _ -> [| error "addEltTH" |]

crucAppToExprTH :: S.App (S.Elt t) ctp -> Q Exp
crucAppToExprTH S.TrueBool  = [| return $ ValueExpr (M.BoolValue True) |]
crucAppToExprTH S.FalseBool = [| return $ ValueExpr (M.BoolValue False) |]
crucAppToExprTH (S.NotBool bool) =
  [| AppExpr (M.NotApp <$> $(addEltTH bool)) |]
crucAppToExprTH (S.AndBool bool1 bool2) =
  [| AppExpr (M.AndApp <$> $(addEltTH bool1) <*> $(addEltTH bool2)) |]
crucAppToExprTH (S.XorBool bool1 bool2) =
  [| AppExpr (M.XorApp <$> $(addEltTH bool1) <*> $(addEltTH bool2)) |]
crucAppToExprTH (S.IteBool test t f) =
  [| AppExpr (M.Mux M.BoolTypeRepr <$> $(addEltTH test) <*> $(addEltTH t) <*> $(addEltTH f)) |]
crucAppToExprTH (S.BVIte w numBranches test t f) =
  [| AppExpr (M.Mux (M.BVTypeRepr $(natReprTH w)) <$> $(addEltTH test) <*> $(addEltTH t) <*> $(addEltTH f)) |]
crucAppToExprTH (S.BVEq bv1 bv2) =
  [| AppExpr (M.Eq           <$> $(addEltTH bv1) <*> $(addEltTH bv2)) |]
crucAppToExprTH (S.BVSlt bv1 bv2) =
  [| AppExpr (M.BVSignedLt   <$> $(addEltTH bv1) <*> $(addEltTH bv2)) |]
crucAppToExprTH (S.BVUlt bv1 bv2) =
  [| AppExpr (M.BVUnsignedLt <$> $(addEltTH bv1) <*> $(addEltTH bv2)) |]
crucAppToExprTH (S.BVConcat w bv1 bv2) = do
  [| error "BVConcat" |]
  -- [| AppExpr (M.BVUnsignedLt <$> $(addEltTH bv1) <*> $(addEltTH bv2)) |]
  -- let u = S.bvWidth bv1
  --     v = S.bvWidth bv2
  -- bv1Val <- addElt bv1
  -- bv2Val <- addElt bv2
  -- S.LeqProof <- return $ S.leqAdd2 (S.leqRefl u) (S.leqProof (knownNat @1) v)
  -- S.LeqProof <- return $ S.leqAdd2 (S.leqRefl v) (S.leqProof (knownNat @1) u)
  -- Refl <- return $ S.plusComm u v
  -- bv1Ext <- addExpr (AppExpr (M.UExt bv1Val w)) ---(u `addNat` v)))
  -- bv2Ext <- addExpr (AppExpr (M.UExt bv2Val w))
  -- bv1Shifter <- addExpr (ValueExpr (M.BVValue w (natValue v)))
  -- bv1Shf <- addExpr (AppExpr (M.BVShl w bv1Ext bv1Shifter))
  -- return $ M.BVOr w bv1Shf bv2Ext
crucAppToExprTH (S.BVSelect idx n bv) = do
  [| error "BVSelect" |]
  -- let w = S.bvWidth bv
  -- bvVal <- addElt bv
  -- case natValue n + 1 <= natValue w of
  --   True -> do
  --     -- Is there a way to just "know" that n + 1 <= w?
  --     Just S.LeqProof <- return $ S.testLeq (n `addNat` (knownNat @1)) w
  --     pf1@S.LeqProof <- return $ S.leqAdd2 (S.leqRefl idx) (S.leqProof (knownNat @1) n)
  --     pf2@S.LeqProof <- return $ S.leqAdd (S.leqRefl (knownNat @1)) idx
  --     Refl <- return $ S.plusComm (knownNat @1) idx
  --     pf3@S.LeqProof <- return $ S.leqTrans pf2 pf1
  --     S.LeqProof <- return $ S.leqTrans pf3 (S.leqProof (idx `addNat` n) w)
  --     bvShf <- addExpr (AppExpr (M.BVShr w bvVal (M.mkLit w (natValue idx))))
  --     return $ AppExpr (M.Trunc bvShf n)
  --   False -> do
  --     -- Is there a way to just "know" that n = w?
  --     Just Refl <- return $ testEquality n w
  --     return $ ValueExpr bvVal
crucAppToExprTH (S.BVNeg w bv) = do
  [| error "BVNeg" |]
  -- bvVal  <- addElt bv
  -- bvComp <- addExpr (AppExpr (M.BVComplement w bvVal))
  -- return $ AppExpr (M.BVAdd w bvComp (M.mkLit w 1))
crucAppToExprTH (S.BVTestBit idx bv) = do
  -- Note: below is untested, could be wrong.
  [| do let bitExp = ValueExpr (M.BVValue $(natReprTH (S.bvWidth bv)) $(lift idx))
        bitExpVal <- addExpr bitExp
        AppExpr <$> (M.BVTestBit <$> bitExpVal <*> $(addEltTH bv)) |]
crucAppToExprTH (S.BVAdd w bv1 bv2) =
  [| AppExpr <$> (M.BVAdd $(natReprTH w) <$> $(addEltTH bv1) <*> $(addEltTH bv2)) |]
crucAppToExprTH (S.BVMul w bv1 bv2) =
  [| AppExpr <$> (M.BVMul $(natReprTH w) <$> $(addEltTH bv1) <*> $(addEltTH bv2)) |]
crucAppToExprTH (S.BVShl w bv1 bv2) =
  [| AppExpr <$> (M.BVShl $(natReprTH w) <$> $(addEltTH bv1) <*> $(addEltTH bv2)) |]
crucAppToExprTH (S.BVLshr w bv1 bv2) =
  [| AppExpr <$> (M.BVShr $(natReprTH w) <$> $(addEltTH bv1) <*> $(addEltTH bv2)) |]
crucAppToExprTH (S.BVAshr w bv1 bv2) =
  [| AppExpr <$> (M.BVSar $(natReprTH w) <$> $(addEltTH bv1) <*> $(addEltTH bv2)) |]
crucAppToExprTH (S.BVZext w bv) =
  -- [| AppExpr <$> (M.UExt <$> $(addEltTH bv) <*> (pure $(natReprTH w))) |]
  [| undefined |]
  -- [| do val <- $(addEltTH bv)
  -- return $ AppExpr (M.UExt val $(natReprTH w)) |]
crucAppToExprTH (S.BVSext w bv) =
  -- [| AppExpr <$> (M.SExt <$> $(addEltTH bv) <*> (pure $(natReprTH w))) |]
  [| undefined |]
crucAppToExprTH (S.BVTrunc w bv) =
  [| AppExpr <$> (M.Trunc <$> $(addEltTH bv) <*> (pure $(natReprTH w))) |]
crucAppToExprTH (S.BVBitNot w bv) =
  [| AppExpr <$> (M.BVComplement <$> $(addEltTH bv) <*> (pure $(natReprTH w))) |]
crucAppToExprTH (S.BVBitAnd w bv1 bv2) =
  [| AppExpr <$> (M.BVAnd  $(natReprTH w) <$> $(addEltTH bv1) <*> $(addEltTH bv2)) |]
crucAppToExprTH (S.BVBitOr w bv1 bv2) =
  [| AppExpr <$> (M.BVOr  $(natReprTH w) <$> $(addEltTH bv1) <*> $(addEltTH bv2)) |]
crucAppToExprTH (S.BVBitXor w bv1 bv2) =
  [| AppExpr <$> (M.BVXor $(natReprTH w) <$> $(addEltTH bv1) <*> $(addEltTH bv2)) |]



crucAppToExpr :: S.App (S.Elt t) ctp -> PPCGenerator ppc ids (Expr ppc ids (FromCrucibleBaseType ctp))
crucAppToExpr S.TrueBool  = return $ ValueExpr (M.BoolValue True)
crucAppToExpr S.FalseBool = return $ ValueExpr (M.BoolValue False)
crucAppToExpr (S.NotBool bool) = (AppExpr . M.NotApp) <$> addElt bool
crucAppToExpr (S.AndBool bool1 bool2) = AppExpr <$> do
  M.AndApp <$> addElt bool1 <*> addElt bool2
crucAppToExpr (S.XorBool bool1 bool2) = AppExpr <$> do
  M.XorApp <$> addElt bool1 <*> addElt bool2
crucAppToExpr (S.IteBool test t f) = AppExpr <$> do
  M.Mux <$> pure M.BoolTypeRepr <*> addElt test <*> addElt t <*> addElt f
crucAppToExpr (S.BVIte w numBranches test t f) = AppExpr <$> do -- what is numBranches for?
  M.Mux <$> pure (M.BVTypeRepr w) <*> addElt test <*> addElt t <*> addElt f
crucAppToExpr (S.BVEq bv1 bv2) = AppExpr <$> do
  M.Eq <$> addElt bv1 <*> addElt bv2
crucAppToExpr (S.BVSlt bv1 bv2) = AppExpr <$> do
  M.BVSignedLt <$> addElt bv1 <*> addElt bv2
crucAppToExpr (S.BVUlt bv1 bv2) = AppExpr <$> do
  M.BVUnsignedLt <$> addElt bv1 <*> addElt bv2
crucAppToExpr (S.BVConcat w bv1 bv2) = AppExpr <$> do
  let u = S.bvWidth bv1
      v = S.bvWidth bv2
  bv1Val <- addElt bv1
  bv2Val <- addElt bv2
  S.LeqProof <- return $ S.leqAdd2 (S.leqRefl u) (S.leqProof (knownNat @1) v)
  S.LeqProof <- return $ S.leqAdd2 (S.leqRefl v) (S.leqProof (knownNat @1) u)
  Refl <- return $ S.plusComm u v
  bv1Ext <- addExpr (AppExpr (M.UExt bv1Val w)) ---(u `addNat` v)))
  bv2Ext <- addExpr (AppExpr (M.UExt bv2Val w))
  bv1Shifter <- addExpr (ValueExpr (M.BVValue w (natValue v)))
  bv1Shf <- addExpr (AppExpr (M.BVShl w bv1Ext bv1Shifter))
  return $ M.BVOr w bv1Shf bv2Ext
crucAppToExpr (S.BVSelect idx n bv) = do
  let w = S.bvWidth bv
  bvVal <- addElt bv
  case natValue n + 1 <= natValue w of
    True -> do
      -- Is there a way to just "know" that n + 1 <= w?
      Just S.LeqProof <- return $ S.testLeq (n `addNat` (knownNat @1)) w
      pf1@S.LeqProof <- return $ S.leqAdd2 (S.leqRefl idx) (S.leqProof (knownNat @1) n)
      pf2@S.LeqProof <- return $ S.leqAdd (S.leqRefl (knownNat @1)) idx
      Refl <- return $ S.plusComm (knownNat @1) idx
      pf3@S.LeqProof <- return $ S.leqTrans pf2 pf1
      S.LeqProof <- return $ S.leqTrans pf3 (S.leqProof (idx `addNat` n) w)
      bvShf <- addExpr (AppExpr (M.BVShr w bvVal (M.mkLit w (natValue idx))))
      return $ AppExpr (M.Trunc bvShf n)
    False -> do
      -- Is there a way to just "know" that n = w?
      Just Refl <- return $ testEquality n w
      return $ ValueExpr bvVal
crucAppToExpr (S.BVNeg w bv) = do
  bvVal  <- addElt bv
  bvComp <- addExpr (AppExpr (M.BVComplement w bvVal))
  return $ AppExpr (M.BVAdd w bvComp (M.mkLit w 1))
crucAppToExpr (S.BVTestBit idx bv) = AppExpr <$> do
  M.BVTestBit
    <$> addExpr (ValueExpr (M.BVValue (S.bvWidth bv) (fromIntegral idx)))
    <*> addElt bv
crucAppToExpr (S.BVAdd repr bv1 bv2) = AppExpr <$> do
  M.BVAdd <$> pure repr <*> addElt bv1 <*> addElt bv2
crucAppToExpr (S.BVMul repr bv1 bv2) = AppExpr <$> do
  M.BVMul <$> pure repr <*> addElt bv1 <*> addElt bv2
crucAppToExpr (S.BVShl repr bv1 bv2) = AppExpr <$> do
  M.BVShl <$> pure repr <*> addElt bv1 <*> addElt bv2
crucAppToExpr (S.BVLshr repr bv1 bv2) = AppExpr <$> do
  M.BVShr <$> pure repr <*> addElt bv1 <*> addElt bv2
crucAppToExpr (S.BVAshr repr bv1 bv2) = AppExpr <$> do
  M.BVSar <$> pure repr <*> addElt bv1 <*> addElt bv2
crucAppToExpr (S.BVZext repr bv) = AppExpr <$> do
  M.UExt <$> addElt bv <*> pure repr
crucAppToExpr (S.BVSext repr bv) = AppExpr <$> do
  M.SExt <$> addElt bv <*> pure repr
crucAppToExpr (S.BVTrunc repr bv) = AppExpr <$> do
  M.Trunc <$> addElt bv <*> pure repr
crucAppToExpr (S.BVBitNot repr bv) = AppExpr <$> do
  M.BVComplement <$> pure repr <*> addElt bv
crucAppToExpr (S.BVBitAnd repr bv1 bv2) = AppExpr <$> do
  M.BVAnd <$> pure repr <*> addElt bv1 <*> addElt bv2
crucAppToExpr (S.BVBitOr repr bv1 bv2) = AppExpr <$> do
  M.BVOr <$> pure repr <*> addElt bv1 <*> addElt bv2
crucAppToExpr (S.BVBitXor repr bv1 bv2) = AppExpr <$> do
  M.BVXor <$> pure repr <*> addElt bv1 <*> addElt bv2
crucAppToExpr _ = error "crucAppToExpr: unimplemented crucible operation"


locToReg :: (1 <= APPC.ArchRegWidth ppc,
             M.RegAddrWidth (PPCReg ppc) ~ APPC.ArchRegWidth ppc)
         => proxy ppc
         -> APPC.Location ppc ctp
         -> PPCReg ppc (FromCrucibleBaseType ctp)
locToReg _ (APPC.LocGPR gpr) = PPC_GP gpr
locToReg _  APPC.LocIP       = PPC_IP
locToReg _  APPC.LocLNK      = PPC_LNK
locToReg _  APPC.LocCTR      = PPC_CTR
locToReg _  APPC.LocCR       = PPC_CR
-- fill the rest out later

locToRegTH :: (1 <= APPC.ArchRegWidth ppc,
               M.RegAddrWidth (PPCReg ppc) ~ APPC.ArchRegWidth ppc)
           => proxy ppc
           -> APPC.Location ppc ctp
           -> Q Exp
locToRegTH _ (APPC.LocGPR (D.GPR gpr)) = [| PPC_GP (D.GPR $(lift gpr)) |]
locToRegTH _  APPC.LocIP       = [| PPC_IP |]
locToRegTH _  APPC.LocLNK      = [| PPC_LNK |]
locToRegTH _  APPC.LocCTR      = [| PPC_CTR |]
locToRegTH _  APPC.LocCR       = [| PPC_CR |]
locToRegTH _  _                = [| undefined |]
-- fill the rest out later

-- | Given a location to modify and a crucible formula, construct a PPCGenerator that
-- will modify the location by the function encoded in the formula.
interpretFormula :: forall tp ppc t ctp s .
                    (1 <= APPC.ArchRegWidth ppc,
                     M.RegAddrWidth (PPCReg ppc) ~ APPC.ArchRegWidth ppc)
                 => APPC.Location ppc ctp
                 -> S.Elt t ctp
                 -> PPCGenerator ppc s ()
interpretFormula loc elt = do
  expr <- eltToExpr elt
  let reg  = (locToReg (Proxy @ppc) loc)
  case expr of
    ValueExpr val -> curPPCState . M.boundValue reg .= val
    AppExpr app -> do
      assignment <- addAssignment (M.EvalApp app)
      curPPCState . M.boundValue reg .= M.AssignedValue assignment
