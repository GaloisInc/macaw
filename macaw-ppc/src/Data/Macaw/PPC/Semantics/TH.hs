{-# LANGUAGE DataKinds #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE TypeApplications #-}

module Data.Macaw.PPC.Semantics.TH
  ( genExecInstruction
  ) where

import qualified Data.ByteString as BS
import qualified Data.Constraint as C

import Control.Lens
import Data.Proxy
import Language.Haskell.TH
import Language.Haskell.TH.Syntax
import GHC.TypeLits

import           Data.Parameterized.Classes
import           Data.Parameterized.FreeParamF ( FreeParamF(..) )
import qualified Data.Parameterized.Lift as LF
import qualified Data.Parameterized.Map as Map
import qualified Data.Parameterized.Nonce as PN
import qualified Data.Parameterized.ShapedList as SL
import           Data.Parameterized.Some ( Some(..) )
import qualified Data.Parameterized.TraversableFC as FC
import           Data.Parameterized.Witness ( Witness(..) )
import qualified Lang.Crucible.Solver.Interface as SI
import qualified Lang.Crucible.Solver.SimpleBuilder as S
import qualified Lang.Crucible.Solver.SimpleBackend as S
import qualified Lang.Crucible.BaseTypes as S

import qualified Dismantle.PPC as D
import qualified Dismantle.Tablegen.TH.Capture as DT

import qualified SemMC.BoundVar as BV
import           SemMC.Formula
import qualified SemMC.Architecture as A
import qualified SemMC.Architecture.Location as L
import qualified SemMC.Architecture.PPC.Location as APPC
import qualified Data.Macaw.CFG as M
import qualified Data.Macaw.Types as M

import Data.Parameterized.NatRepr ( knownNat
                                  , addNat
                                  , natValue
                                  , isPosNat
                                  , testLeq
                                  )

import Data.Macaw.PPC.Generator
import Data.Macaw.PPC.PPCReg

-- | A different parameterized pair wrapper; the one in Data.Parameterized.Map
-- hides the @tp@ parameter under an existential, while we need the variant that
-- exposes it.
data PairF a b tp = PairF (a tp) (b tp)

-- | Generate the top-level lambda with a case expression over an instruction
-- (casing on opcode)
--
-- > \ipVar (Instruction opcode operandList) ->
-- >   case opcode of
-- >     ${CASES}
--
-- where each case in ${CASES} is defined by 'mkSemanticsCase'; each case
-- matches one opcode.
instructionMatcher :: (OrdF a, LF.LiftF a)
                   => Map.MapF (Witness c a) (PairF (ParameterizedFormula (Sym t) arch) (DT.CaptureInfo c a))
                   -> Q Exp
instructionMatcher formulas = do
  ipVarName <- newName "ipVal"
  opcodeVar <- newName "opcode"
  operandListVar <- newName "operands"
  let cases = map (mkSemanticsCase ipVarName operandListVar) (Map.toList formulas)
  lamE [varP ipVarName, conP 'D.Instruction [varP opcodeVar, varP operandListVar]] (caseE (varE opcodeVar) cases)

-- | Generate a single case for one opcode of the case expression.
--
-- > ADD4 -> ${BODY}
--
-- where the ${BODY} is generated by 'mkOperandListCase'
mkSemanticsCase :: (LF.LiftF a)
                => Name
                -> Name
                -> Map.Pair (Witness c a) (PairF (ParameterizedFormula (Sym t) arch) (DT.CaptureInfo c a))
                -> MatchQ
mkSemanticsCase ipVarName operandListVar (Map.Pair (Witness opc) (PairF semantics capInfo)) =
  match (conP (DT.capturedOpcodeName capInfo) []) (normalB (mkOperandListCase ipVarName operandListVar opc semantics capInfo)) []

-- | For each opcode case, we have a sub-case expression to destructure the
-- operand list into names that we can reference.  This generates an expression
-- of the form:
--
-- > case operandList of
-- >   op1 :> op2 :> op3 :> Nil -> ${BODY}
--
-- where ${BODY} is generated by 'genCaseBody', which references the operand
-- names introduced by this case (e.g., op1, op2, op3).  Those names are pulled
-- from the DT.CaptureInfo, and have been pre-allocated.  See
-- Dismantle.Tablegen.TH.Capture.captureInfo for information on how those names
-- are generated.
--
-- Note that the structure of the operand list is actually a little more
-- complicated than the above.  Each operand actually has an additional level of
-- wrapper around it, and really looks like:
--
-- >    Dismantle.PPC.ADD4
-- >      -> case operands_ayaa of {
-- >           (Gprc gprc0 :> (Gprc gprc1 :> (Gprc gprc2 :> Nil)))
-- >             -> ${BODY}
--
-- in an example with three general purpose register operands.
mkOperandListCase :: Name -> Name -> a tp -> ParameterizedFormula (Sym t) arch tp -> DT.CaptureInfo c a tp -> Q Exp
mkOperandListCase ipVarName operandListVar opc semantics capInfo = do
  body <- genCaseBody ipVarName opc semantics (DT.capturedOperandNames capInfo)
  DT.genCase capInfo operandListVar body

-- | This is the function that translates formulas (semantics) into expressions
-- that construct macaw terms.
--
-- The stub implementation is essentially
--
-- > undefined ipVar arg1 arg2
--
-- to avoid unused variable warnings.
--
-- The two maps (locVars and opVars) are crucial for translating parameterized
-- formulas into expressions.
genCaseBody :: forall a sh t arch
             . Name
            -> a sh
            -> ParameterizedFormula (Sym t) arch sh
            -> SL.ShapedList (FreeParamF Name) sh
            -> Q Exp
genCaseBody ipVarName opc semantics varNames =
  [| undefined $(tupE (map varE binders)) |]
  where
    binders = ipVarName : FC.toListFC unFreeParamF varNames

    locVars :: Map.MapF (SI.BoundVar (Sym t)) (L.Location arch)
    locVars = Map.foldrWithKey (collectVarForLocation (Proxy @arch)) Map.empty (pfLiteralVars semantics)

    opVars :: Map.MapF (SI.BoundVar (Sym t)) (FreeParamF Name)
    opVars = SL.foldrFCIndexed (collectOperandVars varNames) Map.empty (pfOperandVars semantics)

collectVarForLocation :: forall tp arch proxy t
                       . proxy arch
                      -> L.Location arch tp
                      -> SI.BoundVar (Sym t) tp
                      -> Map.MapF (SI.BoundVar (Sym t)) (L.Location arch)
                      -> Map.MapF (SI.BoundVar (Sym t)) (L.Location arch)
collectVarForLocation _ loc bv = Map.insert bv loc

-- | Index variables that map to operands
--
-- We record the TH 'Name' for the 'SI.BoundVar' that stands in for each
-- operand.  The idea will be that we will look up bound variables in this map
-- to be able to compute a TH expression to refer to it.
--
-- We have to unwrap and rewrap the 'FreeParamF' because the type parameter
-- changes when we switch from 'BV.BoundVar' to 'SI.BoundVar'.  See the
-- SemMC.BoundVar module for information about the nature of that change
-- (basically, from 'Symbol' to BaseType).
collectOperandVars :: forall sh tp arch t
                    . SL.ShapedList (FreeParamF Name) sh
                   -> SL.Index sh tp
                   -> BV.BoundVar (Sym t) arch tp
                   -> Map.MapF (SI.BoundVar (Sym t)) (FreeParamF Name)
                   -> Map.MapF (SI.BoundVar (Sym t)) (FreeParamF Name)
collectOperandVars varNames ix (BV.BoundVar bv) m =
  case SL.indexShapedList varNames ix of
    FreeParamF name -> Map.insert bv (FreeParamF name) m

-- | Generate an implementation of 'execInstruction' that runs in the
-- 'PPCGenerator' monad.  We pass in both the original list of semantics files
-- along with the list of opcode info objects.  We can match them up using
-- equality on opcodes (via a MapF).  Generating a combined list up-front would
-- be ideal, but is difficult for various TH reasons (we can't call 'lift' on
-- all of the things we would need to for that).
--
-- The structure of the term produced is documented in 'instructionMatcher'
genExecInstruction :: (A.Architecture arch, OrdF a, ShowF a, LF.LiftF a)
                   => proxy arch
                   -> (forall sh . c sh C.:- BuildOperandList arch sh)
                   -- ^ A constraint implication to let us extract/weaken the
                   -- constraint in our 'Witness' to the required 'BuildOperandList'
                   -> [(Some (Witness c a), BS.ByteString)]
                   -- ^ A list of opcodes (with constraint information
                   -- witnessed) paired with the bytestrings containing their
                   -- semantics.  This comes from semmc.
                   -> [Some (DT.CaptureInfo c a)]
                   -- ^ Extra information for each opcode to let us generate
                   -- some TH to match them.  This comes from the semantics
                   -- definitions in semmc.
                   -> Q Exp
genExecInstruction _ impl semantics captureInfo = do
  Some ng <- runIO PN.newIONonceGenerator
  sym <- runIO (S.newSimpleBackend ng)
  formulas <- runIO (loadFormulas sym impl semantics)
  let formulasWithInfo = foldr (attachInfo formulas) Map.empty captureInfo
  instructionMatcher formulasWithInfo
  where
    attachInfo m0 (Some ci) m =
      let co = DT.capturedOpcode ci
      in case Map.lookup co m0 of
        Nothing -> m
        Just pf -> Map.insert co (PairF pf ci) m

-- SemMC.Formula: instantiateFormula

type Sym t = S.SimpleBackend t

type family FromCrucibleBaseType (btp :: S.BaseType) :: M.Type where
  FromCrucibleBaseType (S.BaseBVType w) = M.BVType w
  FromCrucibleBaseType (S.BaseBoolType) = M.BoolType

-- Unimplemented:

-- Don't need to implement:
--   - all SemiRing operations (not using)
--   - all "Basic arithmetic operations" (not using)
--   - all "Operations that introduce irrational numbers" (not using)
--   - BVUnaryTerm (not using)
--   - all array operations (probably not using)
--   - all conversions
--   - all complex operations
--   - all structs

-- Might need to implement later:
--   - BVUdiv, BVUrem, BVSdiv, BVSrem

addExpr :: Expr ppc ids tp -> PPCGenerator ppc ids (M.Value ppc ids tp)
addExpr expr = do
  case expr of
    ValueExpr val -> return val
    AppExpr app -> do
      assignment <- addAssignment (M.EvalApp app)
      return $ M.AssignedValue assignment

addExprTH :: Expr ppc ids tp -> Q Exp
addExprTH expr = do
  undefined

addElt :: S.Elt t ctp -> PPCGenerator ppc ids (M.Value ppc ids (FromCrucibleBaseType ctp))
addElt elt = eltToExpr elt >>= addExpr

-- combine this with addElt
eltToExpr :: S.Elt t ctp -> PPCGenerator ppc ids (Expr ppc ids (FromCrucibleBaseType ctp))
eltToExpr (S.BVElt w val loc) = return $ ValueExpr (M.BVValue w val)
eltToExpr (S.AppElt appElt) = crucAppToExpr (S.appEltApp appElt)
eltToExpr (S.BoundVarElt sbv) = undefined

addElt' :: S.Elt t ctp -> PPCGenerator ppc ids (M.Value ppc ids (FromCrucibleBaseType ctp))
addElt' elt = case elt of
  S.BVElt w val loc -> return $ M.BVValue w val
  S.AppElt appElt   -> do x <- crucAppToExpr (S.appEltApp appElt)
                          addExpr x
  S.BoundVarElt sbv -> undefined

natReprTH :: M.NatRepr w -> Q Exp
natReprTH w = [| knownNat :: M.NatRepr $(litT (return $ NumTyLit (natValue w))) |]

addEltTH :: S.Elt t ctp -> Q Exp
addEltTH elt = case elt of
  S.BVElt w val loc ->
    [| return (M.BVValue $(natReprTH w) $(lift val)) |]
  S.AppElt appElt -> do
    x <- newName "x"
    let app = S.appEltApp appElt
    appExpr <- crucAppToExprTH app
    [| do $(varP x) <- $(crucAppToExprTH (S.appEltApp appElt))
          addExpr $(varE x)
     |]

crucAppToExpr :: S.App (S.Elt t) ctp -> PPCGenerator ppc ids (Expr ppc ids (FromCrucibleBaseType ctp))
crucAppToExpr S.TrueBool  = return $ ValueExpr (M.BoolValue True)
crucAppToExpr S.FalseBool = return $ ValueExpr (M.BoolValue False)
crucAppToExpr (S.NotBool bool) = (AppExpr . M.NotApp) <$> addElt bool
crucAppToExpr (S.AndBool bool1 bool2) = AppExpr <$> do
  M.AndApp <$> addElt bool1 <*> addElt bool2
crucAppToExpr (S.XorBool bool1 bool2) = AppExpr <$> do
  M.XorApp <$> addElt bool1 <*> addElt bool2
crucAppToExpr (S.IteBool test t f) = AppExpr <$> do
  M.Mux <$> pure M.BoolTypeRepr <*> addElt test <*> addElt t <*> addElt f
crucAppToExpr (S.BVIte w numBranches test t f) = AppExpr <$> do -- what is numBranches for?
  M.Mux <$> pure (M.BVTypeRepr w) <*> addElt test <*> addElt t <*> addElt f
crucAppToExpr (S.BVEq bv1 bv2) = AppExpr <$> do
  M.Eq <$> addElt bv1 <*> addElt bv2
crucAppToExpr (S.BVSlt bv1 bv2) = AppExpr <$> do
  M.BVSignedLt <$> addElt bv1 <*> addElt bv2
crucAppToExpr (S.BVUlt bv1 bv2) = AppExpr <$> do
  M.BVUnsignedLt <$> addElt bv1 <*> addElt bv2
crucAppToExpr (S.BVConcat w bv1 bv2) = AppExpr <$> do
  let u = S.bvWidth bv1
      v = S.bvWidth bv2
  bv1Val <- addElt bv1
  bv2Val <- addElt bv2
  S.LeqProof <- return $ S.leqAdd2 (S.leqRefl u) (S.leqProof (knownNat @1) v)
  S.LeqProof <- return $ S.leqAdd2 (S.leqRefl v) (S.leqProof (knownNat @1) u)
  Refl <- return $ S.plusComm u v
  bv1Ext <- addExpr (AppExpr (M.UExt bv1Val w)) ---(u `addNat` v)))
  bv2Ext <- addExpr (AppExpr (M.UExt bv2Val w))
  bv1Shifter <- addExpr (ValueExpr (M.BVValue w (natValue v)))
  bv1Shf <- addExpr (AppExpr (M.BVShl w bv1Ext bv1Shifter))
  return $ M.BVOr w bv1Shf bv2Ext
crucAppToExpr (S.BVSelect idx n bv) = do
  let w = S.bvWidth bv
  bvVal <- addElt bv
  case natValue n + 1 <= natValue w of
    True -> do
      -- Is there a way to just "know" that n + 1 <= w?
      Just S.LeqProof <- return $ S.testLeq (n `addNat` (knownNat @1)) w
      pf1@S.LeqProof <- return $ S.leqAdd2 (S.leqRefl idx) (S.leqProof (knownNat @1) n)
      pf2@S.LeqProof <- return $ S.leqAdd (S.leqRefl (knownNat @1)) idx
      Refl <- return $ S.plusComm (knownNat @1) idx
      pf3@S.LeqProof <- return $ S.leqTrans pf2 pf1
      S.LeqProof <- return $ S.leqTrans pf3 (S.leqProof (idx `addNat` n) w)
      bvShf <- addExpr (AppExpr (M.BVShr w bvVal (M.mkLit w (natValue idx))))
      return $ AppExpr (M.Trunc bvShf n)
    False -> do
      -- Is there a way to just "know" that n = w?
      Just Refl <- return $ testEquality n w
      return $ ValueExpr bvVal
crucAppToExpr (S.BVNeg w bv) = do
  bvVal  <- addElt bv
  bvComp <- addExpr (AppExpr (M.BVComplement w bvVal))
  return $ AppExpr (M.BVAdd w bvComp (M.mkLit w 1))
crucAppToExpr (S.BVTestBit idx bv) = AppExpr <$> do
  M.BVTestBit
    <$> addExpr (ValueExpr (M.BVValue (S.bvWidth bv) (fromIntegral idx)))
    <*> addElt bv
crucAppToExpr (S.BVAdd repr bv1 bv2) = AppExpr <$> do
  M.BVAdd <$> pure repr <*> addElt bv1 <*> addElt bv2
crucAppToExpr (S.BVMul repr bv1 bv2) = AppExpr <$> do
  M.BVMul <$> pure repr <*> addElt bv1 <*> addElt bv2
crucAppToExpr (S.BVShl repr bv1 bv2) = AppExpr <$> do
  M.BVShl <$> pure repr <*> addElt bv1 <*> addElt bv2
crucAppToExpr (S.BVLshr repr bv1 bv2) = AppExpr <$> do
  M.BVShr <$> pure repr <*> addElt bv1 <*> addElt bv2
crucAppToExpr (S.BVAshr repr bv1 bv2) = AppExpr <$> do
  M.BVSar <$> pure repr <*> addElt bv1 <*> addElt bv2
crucAppToExpr (S.BVZext repr bv) = AppExpr <$> do
  M.UExt <$> addElt bv <*> pure repr
crucAppToExpr (S.BVSext repr bv) = AppExpr <$> do
  M.SExt <$> addElt bv <*> pure repr
crucAppToExpr (S.BVTrunc repr bv) = AppExpr <$> do
  M.Trunc <$> addElt bv <*> pure repr
crucAppToExpr (S.BVBitNot repr bv) = AppExpr <$> do
  M.BVComplement <$> pure repr <*> addElt bv
crucAppToExpr (S.BVBitAnd repr bv1 bv2) = AppExpr <$> do
  M.BVAnd <$> pure repr <*> addElt bv1 <*> addElt bv2
crucAppToExpr (S.BVBitOr repr bv1 bv2) = AppExpr <$> do
  M.BVOr <$> pure repr <*> addElt bv1 <*> addElt bv2
crucAppToExpr (S.BVBitXor repr bv1 bv2) = AppExpr <$> do
  M.BVXor <$> pure repr <*> addElt bv1 <*> addElt bv2
crucAppToExpr _ = error "crucAppToExpr: unimplemented crucible operation"

crucAppToExprTH :: S.App (S.Elt t) ctp -> Q Exp
crucAppToExprTH S.TrueBool  = [| return $ ValueExpr (M.BoolValue True) |]
crucAppToExprTH S.FalseBool = [| return $ ValueExpr (M.BoolValue False) |]
crucAppToExprTH (S.NotBool bool) = do
  boolExp <- addEltTH bool
  [| AppExpr (M.NotApp $(return boolExp)) |]
crucAppToExprTH (S.AndBool bool1 bool2) = do
  bool1Exp <- addEltTH bool1
  bool2Exp <- addEltTH bool2
  [| AppExpr (M.AndApp $(return bool1Exp) $(return bool2Exp)) |]
crucAppToExprTH (S.XorBool bool1 bool2) = do
  bool1Exp <- addEltTH bool1
  bool2Exp <- addEltTH bool2
  [| AppExpr (M.AndApp $(return bool1Exp) $(return bool2Exp)) |]
crucAppToExprTH (S.IteBool test t f) = do
  testExp <- addEltTH test
  tExp    <- addEltTH t
  fExp    <- addEltTH f
  [| AppExpr (M.Mux M.BoolTypeRepr $(return testExp) $(return tExp) $(return fExp)) |]
crucAppToExprTH (S.BVIte w numBranches test t f) = do
  testExp <- addEltTH test
  tExp    <- addEltTH t
  fExp    <- addEltTH f
  [| AppExpr (M.Mux (M.BVTypeRepr $(natReprTH w)) $(return testExp) $(return tExp) $(return fExp)) |]
crucAppToExprTH (S.BVEq bv1 bv2) = do
  bv1Exp <- addEltTH bv1
  bv2Exp <- addEltTH bv2
  [| AppExpr (M.Eq $(return bv1Exp) $(return bv2Exp)) |]
crucAppToExprTH (S.BVSlt bv1 bv2) = do
  bv1Exp <- addEltTH bv1
  bv2Exp <- addEltTH bv2
  [| AppExpr (M.BVSignedLt $(return bv1Exp) $(return bv2Exp)) |]
crucAppToExprTH (S.BVUlt bv1 bv2) = do
  bv1Exp <- addEltTH bv1
  bv2Exp <- addEltTH bv2
  [| AppExpr (M.BVUnsignedLt $(return bv1Exp) $(return bv2Exp)) |]
crucAppToExprTH (S.BVConcat w bv1 bv2) = do
  undefined
  -- let u = S.bvWidth bv1
  --     v = S.bvWidth bv2
  -- bv1Val <- addElt bv1
  -- bv2Val <- addElt bv2
  -- S.LeqProof <- return $ S.leqAdd2 (S.leqRefl u) (S.leqProof (knownNat @1) v)
  -- S.LeqProof <- return $ S.leqAdd2 (S.leqRefl v) (S.leqProof (knownNat @1) u)
  -- Refl <- return $ S.plusComm u v
  -- bv1Ext <- addExpr (AppExpr (M.UExt bv1Val w)) ---(u `addNat` v)))
  -- bv2Ext <- addExpr (AppExpr (M.UExt bv2Val w))
  -- bv1Shifter <- addExpr (ValueExpr (M.BVValue w (natValue v)))
  -- bv1Shf <- addExpr (AppExpr (M.BVShl w bv1Ext bv1Shifter))
  -- return $ M.BVOr w bv1Shf bv2Ext
crucAppToExprTH (S.BVSelect idx n bv) = do
  undefined
  -- let w = S.bvWidth bv
  -- bvVal <- addElt bv
  -- case natValue n + 1 <= natValue w of
  --   True -> do
  --     -- Is there a way to just "know" that n + 1 <= w?
  --     Just S.LeqProof <- return $ S.testLeq (n `addNat` (knownNat @1)) w
  --     pf1@S.LeqProof <- return $ S.leqAdd2 (S.leqRefl idx) (S.leqProof (knownNat @1) n)
  --     pf2@S.LeqProof <- return $ S.leqAdd (S.leqRefl (knownNat @1)) idx
  --     Refl <- return $ S.plusComm (knownNat @1) idx
  --     pf3@S.LeqProof <- return $ S.leqTrans pf2 pf1
  --     S.LeqProof <- return $ S.leqTrans pf3 (S.leqProof (idx `addNat` n) w)
  --     bvShf <- addExpr (AppExpr (M.BVShr w bvVal (M.mkLit w (natValue idx))))
  --     return $ AppExpr (M.Trunc bvShf n)
  --   False -> do
  --     -- Is there a way to just "know" that n = w?
  --     Just Refl <- return $ testEquality n w
  --     return $ ValueExpr bvVal
crucAppToExprTH (S.BVNeg w bv) = do
  undefined
  -- bvVal  <- addElt bv
  -- bvComp <- addExpr (AppExpr (M.BVComplement w bvVal))
  -- return $ AppExpr (M.BVAdd w bvComp (M.mkLit w 1))
crucAppToExprTH (S.BVTestBit idx bv) = do
  bitExp <- addExprTH (ValueExpr (M.BVValue (S.bvWidth bv) (fromIntegral idx)))
  bvExp  <- addEltTH bv
  [| AppExpr (M.BVTestBit $(return bitExp) $(return bvExp)) |]
crucAppToExprTH (S.BVAdd w bv1 bv2) = do
  bv1Exp <- addEltTH bv1
  bv2Exp <- addEltTH bv2
  [| AppExpr (M.BVAdd $(natReprTH w) $(return bv1Exp) $(return bv2Exp)) |]
crucAppToExprTH (S.BVMul w bv1 bv2) = do
  bv1Exp <- addEltTH bv1
  bv2Exp <- addEltTH bv2
  [| AppExpr (M.BVMul $(natReprTH w) $(return bv1Exp) $(return bv2Exp)) |]
crucAppToExprTH (S.BVShl w bv1 bv2) = do
  bv1Exp <- addEltTH bv1
  bv2Exp <- addEltTH bv2
  [| AppExpr (M.BVShl $(natReprTH w) $(return bv1Exp) $(return bv2Exp)) |]
crucAppToExprTH (S.BVLshr w bv1 bv2) = do
  bv1Exp <- addEltTH bv1
  bv2Exp <- addEltTH bv2
  [| AppExpr (M.BVShr $(natReprTH w) $(return bv1Exp) $(return bv2Exp)) |]
crucAppToExprTH (S.BVAshr w bv1 bv2) = do
  bv1Exp <- addEltTH bv1
  bv2Exp <- addEltTH bv2
  [| AppExpr (M.BVSar $(natReprTH w) $(return bv1Exp) $(return bv2Exp)) |]
crucAppToExprTH (S.BVZext w bv) = do
  bvExp <- addEltTH bv
  [| AppExpr (M.UExt $(return bvExp) $(natReprTH w)) |]
crucAppToExprTH (S.BVSext w bv) = do
  bvExp <- addEltTH bv
  [| AppExpr (M.SExt $(return bvExp) $(natReprTH w)) |]
crucAppToExprTH (S.BVTrunc w bv) = do
  bvExp <- addEltTH bv
  [| AppExpr (M.Trunc $(return bvExp) $(natReprTH w)) |]
crucAppToExprTH (S.BVBitNot w bv) = do
  bvExp <- addEltTH bv
  [| AppExpr (M.BVComplement $(return bvExp) $(natReprTH w)) |]
crucAppToExprTH (S.BVBitAnd w bv1 bv2) = do
  bv1Exp <- addEltTH bv1
  bv2Exp <- addEltTH bv2
  [| AppExpr (M.BVAnd $(natReprTH w) $(return bv1Exp) $(return bv2Exp)) |]
crucAppToExprTH (S.BVBitOr w bv1 bv2) = do
  bv1Exp <- addEltTH bv1
  bv2Exp <- addEltTH bv2
  [| AppExpr (M.BVOr $(natReprTH w) $(return bv1Exp) $(return bv2Exp)) |]
crucAppToExprTH (S.BVBitXor w bv1 bv2) = do
  bv1Exp <- addEltTH bv1
  bv2Exp <- addEltTH bv2
  [| AppExpr (M.BVXor $(natReprTH w) $(return bv1Exp) $(return bv2Exp)) |]


locToReg :: (1 <= APPC.ArchRegWidth ppc,
             M.RegAddrWidth (PPCReg ppc) ~ APPC.ArchRegWidth ppc)
         => proxy ppc
         -> APPC.Location ppc ctp
         -> PPCReg ppc (FromCrucibleBaseType ctp)
locToReg _ (APPC.LocGPR gpr) = PPC_GP gpr
locToReg _  APPC.LocIP       = PPC_IP
locToReg _  APPC.LocLNK      = PPC_LNK
locToReg _  APPC.LocCTR      = PPC_CTR
locToReg _  APPC.LocCR       = PPC_CR
-- fill the rest out later

-- | Given a location to modify and a crucible formula, construct a PPCGenerator that
-- will modify the location by the function encoded in the formula.
interpretFormula :: forall tp ppc t ctp s .
                    (1 <= APPC.ArchRegWidth ppc,
                     M.RegAddrWidth (PPCReg ppc) ~ APPC.ArchRegWidth ppc)
                 => APPC.Location ppc ctp
                 -> S.Elt t ctp
                 -> PPCGenerator ppc s ()
interpretFormula loc elt = do
  expr <- eltToExpr elt
  let reg  = (locToReg (Proxy @ppc) loc)
  case expr of
    ValueExpr val -> curPPCState . M.boundValue reg .= val
    AppExpr app -> do
      assignment <- addAssignment (M.EvalApp app)
      curPPCState . M.boundValue reg .= M.AssignedValue assignment
